\documentclass{scrartcl}

\deffootnote{1em}{1em}{\textsuperscript{\thefootnotemark}}

\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}

\usepackage
    [bitstream-charter,greekuppercase=italicized]
    {mathdesign}
\renewcommand{\sfdefault}{fvs}
\renewcommand{\ttdefault}{fvm}

\usepackage[utf8x]{inputenc}

\SetUnicodeOption{mathletters}

\PreloadUnicodePage{3}

\DeclareMathSymbol{.}{\mathrel}{letters}{"3A}

\usepackage{microtype}

\usepackage[hidelinks]{hyperref}

\usepackage{amsmath}

\newenvironment{mathfigure}[2]
    {%
        \begin{figure}
        \newcommand{\figurelabel}{#1}
        \newcommand{\figurecaption}{#2}
        \centering
        \begin{math}
    }
    {
        \end{math}
        \caption{\figurecaption}
        \label{\figurelabel}
        \end{figure}%
    }

\newcommand{\bnfdef}{\mathrel{{\mathop:}{\mathop:}{=}}}

\newcommand{\optional}{^?}
\newcommand{\some}{^+}
\newcommand{\many}{^*}

\newcommand{\deriv}[2]{\frac{\;#1\;}{\;#2\;}}
\newcommand{\derivlinedone}{\\[\topsep]}
\newcommand{\morederivs}{\qquad}
\newcommand{\nexthyp}{\quad}

\newcommand{\newkw}[1]
           {\expandafter\newcommand\csname kw#1\endcsname{\mathbf{#1}}}

\newkw{let}
\newkw{in}
\newkw{if}
\newkw{then}
\newkw{else}
\newkw{left}
\newkw{right}
\newkw{trace}

\newkw{env}
\newkw{withenv}
\newkw{gate}
\newkw{defer}
\newkw{abort}

\newcommand{\exlet}[2]{\kwlet \; #1 \; \kwin \; #2}
\newcommand{\exif}[3]{\kwif \; #1 \; \kwthen \; #2 \; \kwelse \; #3}
\newcommand{\exlam}[2]{\backslash \; #1 → #2}
\newcommand{\exclam}[2]{\# \; #1 → #2}
\newcommand{\exapp}[2]{#1 \; #2}
\newcommand{\exleft}[1]{\kwleft \; #1}
\newcommand{\exright}[1]{\kwright \; #1}
\newcommand{\extrace}[1]{\kwtrace \; #1}

\newcommand{\exwithenv}[1]{\kwwithenv \; #1}
\newcommand{\exgate}[1]{\kwgate \; #1}
\newcommand{\exdefer}[1]{\kwdefer \; #1}
\newcommand{\exabort}[1]{\kwabort \; #1}

\newcommand{\newnt}[1]
           {\expandafter\newcommand\csname#1\endcsname{\mathit{#1}}}

\newnt{Char}
\newnt{Letter}
\newnt{Digit}

\newnt{Token}
\newnt{Ident}
\newnt{Str}
\newnt{Nat}
\newnt{Keyword}
\newnt{Symbol}

\newnt{Prog}
\newnt{Assign}
\newnt{Expr}
\newnt{Let}
\newnt{If}
\newnt{Lam}
\newnt{CLam}
\newnt{App}
\newnt{List}
\newnt{TNat}
\newnt{FNat}
\newnt{Pair}
\newnt{Left}
\newnt{Right}
\newnt{Trace}
\newnt{Var}

\newnt{Zero}
\newnt{Env}
\newnt{WithEnv}
\newnt{Gate}
\newnt{Defer}
\newnt{Abort}

\newcommand{\internal}{_\mathrm{i}}

\newcommand{\suc}[1]{\hat{n}}

\title{Specification of the Stand-in Language}
\author{%
    Wolfgang Jeltsch\\
    \small Well-Typed LLP\\
    \small\texttt{wolfgang@well-typed.com}%
}

\begin{document}

\maketitle

\section{Introduction}

We present a formal specification of the Stand-in Language by Sam
Griffin. Our specification closely resembles the version of the language
implemented in Commit \texttt{966227a} of the
\texttt{sfultong/stand-in-language} GitHub repository.

\section{Syntax}

We distinguish between the surface language and the internal language.
In Section~\ref{desugaring}, we define the translation from the former
to the latter.

We describe all syntax using a variant of Backus–Naur form. Our variant
uses the following notations, listed here in increasing order of
precedence:
\begin{itemize}

\item

Words in italics are nonterminals.

\item

$∣$ denotes set union.

\item

$∖$ denotes set difference.

\item

Mere juxtaposition denotes concatenation.

\item

$\optional$, $\some$, and $\many$ denote optionality, repetition with at
least one occurrence, and arbitrary repetition, respectively.

\item

$⟨$~and~$⟩$ delimit subexpressions and are used for overriding default
precedence.\footnote{We do not use $($ and~$)$ for this purpose, since
they are part of the languages we want to describe.}

\end{itemize}

\subsection{Surface Language}

Figure~\ref{token-syntax-of-the-surface-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-surface-language}
defines the syntax of the language. The nonterminals $\CLam$, $\TNat$,
and $\FNat$ stand for “complete lambda”, “tuple natural”, and “function
natural”, respectively.
\begin{mathfigure}{token-syntax-of-the-surface-language}
                  {Token syntax of the surface language}
%
\begin{aligned}
%
\Token   & \bnfdef \Ident ∣ \Str ∣ \Nat ∣ \Keyword ∣ \Symbol    \\
\Ident   & \bnfdef \Letter⟨\Letter ∣ \Digit ∣ \_ ∣ {′}⟩\many ∖
                   \Keyword                                     \\
\Str     & \bnfdef \text{“}\Char\many\text{”}                   \\
\Nat     & \bnfdef \Digit\some                                  \\
\Keyword & \bnfdef \kwlet ∣ \kwin ∣ \kwif ∣ \kwthen ∣ \kwelse ∣
                   \kwleft ∣ \kwright ∣ \kwtrace                \\
\Symbol  & \bnfdef {=} ∣ {:} ∣ {[} ∣ {]} ∣ {\{} ∣ {\}} ∣ {,} ∣
                   \backslash ∣ \# ∣ {→} ∣ \$ ∣ {(} ∣ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-surface-language}
                  {Syntax of the surface language}
%
\begin{aligned}
%
\Prog   & \bnfdef \Assign\some                                   \\
\Assign & \bnfdef \Ident \; ⟨{:} \; \Expr₀⟩\optional = \Expr₀    \\
\Expr₀  & \bnfdef \Let ∣ \If ∣ \Lam ∣ \CLam ∣ \Expr₁             \\
\Let    & \bnfdef \exlet{\Assign\many}{\Expr₀}                   \\
\If     & \bnfdef \exif{\Expr₀}{\Expr₀}{\Expr₀}                  \\
\Lam    & \bnfdef \exlam{\Var\some}{\Expr₀}                      \\
\CLam   & \bnfdef \exclam{\Var\some}{\Expr₀}                     \\
\Expr₁  & \bnfdef \App ∣ \Expr₂                                  \\
\App    & \bnfdef \exapp{\Expr₁}{\Expr₂}                         \\
\Expr₂  & \bnfdef \List ∣ \Str ∣ \TNat ∣ \FNat ∣ \Pair ∣ \Left ∣
                  \Right ∣ \Trace ∣ \Var ∣ (\Expr₀)              \\
\List   & \bnfdef [] ∣ [\Expr₀ ⟨, \Expr₀⟩\many]                  \\
\TNat   & \bnfdef \Nat                                           \\
\FNat   & \bnfdef \$\Nat                                         \\
\Pair   & \bnfdef \{\Expr₀, \Expr₀\}                             \\
\Left   & \bnfdef \exleft{\Expr₂}                                \\
\Right  & \bnfdef \exright{\Expr₂}                               \\
\Trace  & \bnfdef \extrace{\Expr₂}                               \\
\Var    & \bnfdef \Ident                                         \\
%
\end{aligned}
%
\end{mathfigure}
%NOTE: The vertical bars in the grammar source are not the ASCII
%      character U+007C VERTICAL LINE but the character U+2223 DIVIDES,
%      which the ucs package translates into \mid. This is important to
%      get the proper spacing.

\subsection{Internal Language}

Figure~\ref{token-syntax-of-the-internal-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-internal-language}
defines the syntax of the language.
\begin{mathfigure}{token-syntax-of-the-internal-language}
                  {Token syntax of the internal language}
%
\begin{aligned}
%
\Token\internal   & \bnfdef \Keyword\internal ∣ \Symbol\internal     \\
\Keyword\internal & \bnfdef \kwleft ∣ \kwright ∣ \kwenv ∣ \kwwithenv
                            ∣ \kwgate ∣ \kwdefer ∣ \kwabort ∣
                            \kwtrace                                 \\
\Symbol\internal  & \bnfdef ∅ ∣ {\{} ∣ {\}} ∣ {,} ∣ {(} ∣ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-internal-language}
                  {Syntax of the internal language}
%
\begin{aligned}
%
\Prog\internal  & \bnfdef \Expr\internal                              \\
\Expr\internal  & \bnfdef \Pair\internal ∣ \Left\internal ∣
                          \Right\internal ∣ \Zero ∣ \Env ∣ \WithEnv ∣
                          \Gate ∣ \Defer ∣ \Abort ∣ \Trace\internal ∣
                          (\Expr\internal)                            \\
\Pair\internal  & \bnfdef \{\Expr\internal, \Expr\internal\}          \\
\Left\internal  & \bnfdef \exleft{\Expr\internal}                     \\
\Right\internal & \bnfdef \exright{\Expr\internal}                    \\
\Zero           & \bnfdef ∅                                           \\
\WithEnv        & \bnfdef \exwithenv{\Expr\internal}                  \\
\Env            & \bnfdef \kwenv                                      \\
\Gate           & \bnfdef \exgate{\Expr\internal}                     \\
\Defer          & \bnfdef \exdefer{\Expr\internal}                    \\
\Abort          & \bnfdef \exabort{\Expr\internal}                    \\
\Trace\internal & \bnfdef \extrace{\Expr\internal}
%
\end{aligned}
%
\end{mathfigure}

\section{Desugaring}
\label{desugaring}

For defining desugaring, we introduce the following special meta-syntax:
\begin{itemize}

\item

$⟨e⟩_{x ↦ e′}$ means the expression~$e$ with free occurrences of~$x$
replaced by~$e′$.

\item

$c_\#$ means the natural number literal that represents the code of the
character~$c$.

\item

$\suc{n}$ means the natural number literal that represents the successor
of~$n$.

\item

$f^n x$ means the n-fold application of~$f$ to~$x$, that is,
$\exapp{f}{\exapp{…}{\exapp{f}{\exapp{x}}}}$ where $f$ occurs $n$~times.

\end{itemize}
Furthermore we introduce a helper function~$ρ : \Var\some × \Var →
\Expr\internal$. A term $ρ(Δ, x)$ yields an internal expression that is
evaluated to a pair whose first element is the value of~$x$. The
argument~$Δ$ is called a context. A context is a list of variables that
are in scope, with variables bound closer to the expression being listed
later. We write $Δ ⊳ x$ for the context~$Δ$ extended by~$x$. The
definition of~$ρ$ is as follows:
\begin{equation}
%
ρ(Δ ⊳ x, y) = \begin{cases}
                  \kwenv            & \text{if $x = y$} \\
                  \exright{ρ(Δ, y)} & \text{if $x ≠ y$}
              \end{cases}
%
\end{equation}

Figure~\ref{desugaring-of-expressions} defines a function $⌊−⌋_− : \Expr
× \Var\many → \Expr\internal$ that describes desugaring of expressions.
A term $⌊e⌋_Δ$ gives the internal expression that corresponds to the
surface expression~$e$ under the context~$Δ$. Based on $⌊−⌋_−$ we define
a function $⌊−⌋ : \Prog → \Prog\internal$ that describes desugaring of
programs:
\begin{equation}
%
⌊p⌋ = ⌊\exlet{p}{\mathit{main}}⌋_ε
%
\end{equation}
\begin{mathfigure}{desugaring-of-expressions}{Desugaring of expressions}
%
\newcommand{\nextline}{\\ & \mathrel{\phantom{=}}}
\newcommand{\exapprhs}{
    \kwwithenv
    \nextline
    \quad \kwwithenv \; \{
    \nextline
    \quad\quad \exdefer{
                   \{
                       \exleft{\exright{\kwenv}},
                       \{\exleft{\kwenv}, \exright{\exright{\kwenv}}\}
                   \}
               },
    \nextline
    \quad\quad \{⌊e₂⌋_Δ, ⌊e₁⌋_Δ\}
    \nextline
    \quad \}
}
%
\begin{aligned}
%
⌊\kwlet \; \kwin \; e⌋_Δ         & = ⌊e⌋_Δ                            \\
⌊\exlet{x = e′ \; \bar{a}}{e}⌋_Δ & = ⌊
                                         ⟨\exlet{\bar{a}}{e}⟩
                                             _{x ↦ e′}
                                     ⌋_Δ \\
⌊\exif{e}{e₁}{e₂}⌋_Δ             & = \exwithenv{
                                         \{
                                             \exgate{⌊e⌋_Δ},
                                             \{⌊e₁⌋_Δ, ⌊e₂⌋_Δ\}
                                         \}
                                     }                                \\
⌊\exlam{\bar{x}}{e}⌋_Δ           & = \{
                                         \exdefer{⌊e⌋_{Δ ∘ \bar{x}}},
                                         \kwenv
                                     \}                               \\
⌊\exclam{\bar{x}}{e}⌋_Δ          & = \{
                                         \exdefer{⌊e⌋_{\bar{x}}},
                                         ∅
                                     \}                               \\
⌊\exapp{e₁}{e₂}⌋_Δ               & = \exapprhs                        \\
⌊[]⌋_Δ                           & = ∅                                \\
⌊[e, l]⌋_Δ                       & = \{⌊e⌋_Δ, ⌊[l]⌋_Δ\}               \\
⌊\text{“}\,\text{”}⌋_Δ           & = ∅                                \\
⌊\text{“}c\bar{c}\text{”}⌋_Δ     & = \{
                                         ⌊c_\#⌋_Δ,
                                         ⌊\text{“}\bar{c}\text{”}⌋_Δ
                                     \}  \\
⌊0⌋_Δ                            & = ∅                                \\
⌊\suc{n}⌋_Δ                      & = \{⌊n⌋_Δ, ∅\}                     \\
⌊\${n}⌋_Δ                        & = ⌊\exclam{f \; x}{f^n x}⌋_Δ       \\
⌊\{e₁, e₂\}⌋_Δ                   & = \{⌊e₁⌋_Δ, ⌊e₂⌋_Δ\}               \\
⌊\exleft{e}⌋_Δ                   & = \exleft{⌊e⌋_Δ}                   \\
⌊\exright{e}⌋_Δ                  & = \exright{⌊e⌋_Δ}                  \\
⌊\extrace{e}⌋_Δ                  & = \extrace{⌊e⌋_Δ}                  \\
⌊x⌋_Δ                            & = \exleft{ρ(Δ, x)}                 \\
⌊(e)⌋_Δ                          & = ⌊e⌋_Δ
%
\end{aligned}
%
\end{mathfigure}

\section{Operational Semantics}

Evaluation of an expression happens in the context of an environment,
which is an expression itself. The environment can be read using
$\kwenv$ and set using $\kwwithenv$.

Figure~\ref{operational-semantics} defines a relation ${−} ⊢ {−} → {−} ⊆
\Expr × \Expr × \Expr$ that constitutes the big-step (evaluation)
semantics of the internal language. A proposition $ℰ ⊢ e → e′$ is true
if and only if evaluating the expression~$e$ under the environment~$ℰ$
may yield the expression~$e′$. The semantics only covers the pure
aspects of execution. The $\kwtrace$ construct is actually impure, as it
outputs diagnostic information. Our semantics ignores that, treating any
expression of the form $\extrace{e}$ like~$e$.

The following things about the big-step semantics should be noted:
\begin{itemize}

\item

The relation ${−} ⊢ {−} → {−}$ is actually a partial function. This
means that evaluation is deterministic: it either fails or leads to a
uniquely defined expression.

\item

Evaluation does not necessarily lead to irreducible expressions. There
exist environments~$ℰ$ and expressions $e$, $e′$, and~$e″$ for which $ℰ
⊢ e → e′$ and $ℰ ⊢ e′ → e″$ but $e′ ≠ e″$. For example, $ℰ ⊢
\exdefer{\exdefer{e}} → \exdefer{e}$ and $ℰ ⊢ \exdefer{e} → e$ for any
environment~$ℰ$ and any expression~$e$.

\end{itemize}
\begin{mathfigure}{operational-semantics}{Operational semantics}
%
\begin{gathered}
%
\deriv{ℰ ⊢ e₁ → e₁′ \nexthyp ℰ ⊢ e₂ → e₂′}
      {ℰ ⊢ \{e₁, e₂\} → \{e₁′, e₂′\}}
\derivlinedone
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{e₁, e₂\}}
      {ℰ ⊢ \exleft{e} → e₁}
\derivlinedone
\deriv{ℰ ⊢ e → e′ \nexthyp ∀e₁ \; e₂ . e′≠ \{e₁, e₂\}}
      {ℰ ⊢ \exleft{e} → ∅}
%
\end{gathered}
\morederivs
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{e₁, e₂\}}
      {ℰ ⊢ \exright{e} → e₂}
\derivlinedone
\deriv{ℰ ⊢ e → e′ \nexthyp ∀e₁ \; e₂ . e′≠ \{e₁, e₂\}}
      {ℰ ⊢ \exright{e} → ∅}
%
\end{gathered}
\derivlinedone
\deriv{}
      {ℰ ⊢ ∅ → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → \{e₁, e₂\} \nexthyp e₂ ⊢ e₁ → e′}
      {ℰ ⊢ \exwithenv{e} → e′}
\derivlinedone
\deriv{}
      {ℰ ⊢ \kwenv → ℰ}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exgate{e} → \exleft{\kwenv}}
\morederivs
\deriv{ℰ ⊢ e → e′ \nexthyp e′ ≠ ∅}
      {ℰ ⊢ \exgate{e} → \exright{\kwenv}}
\derivlinedone
\deriv{}
      {ℰ ⊢ \exdefer{e} → e}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exabort{e} → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → e′}
      {ℰ ⊢ \extrace{e} → e′}
\derivlinedone
%
\end{gathered}
%
\end{mathfigure}

\end{document}

\documentclass{scrartcl}

\deffootnote{1em}{1em}{\textsuperscript{\thefootnotemark}}

\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}

\usepackage
    [bitstream-charter,greekuppercase=italicized]
    {mathdesign}
\renewcommand{\sfdefault}{fvs}
\renewcommand{\ttdefault}{fvm}

\usepackage[utf8x]{inputenc}

\SetUnicodeOption{mathletters}

\PreloadUnicodePage{3}
\PreloadUnicodePage{32}
\PreloadUnicodePage{33}
\PreloadUnicodePage{34}
\PreloadUnicodePage{35}
\PreloadUnicodePage{39}
\PreloadUnicodePage{468}

\DeclareMathSymbol{.}{\mathrel}{letters}{"3A}

\usepackage{microtype}

\usepackage{hyperref}

\usepackage{xcolor}

\colorlet{link}{violet}
\colorlet{cite}{brown!70!red!70!black}
\colorlet{url}{blue!80!black}
\hypersetup{colorlinks=true,linkcolor=link,citecolor=cite,urlcolor=url}

\usepackage{amsmath}
\usepackage{amsthm}

\newenvironment{mathfigure}[2]
    {%
        \begin{figure}
        \newcommand{\figurelabel}{#1}
        \newcommand{\figurecaption}{#2}
        \centering
        \begin{math}
    }
    {
        \end{math}
        \caption{\figurecaption}
        \label{\figurelabel}
        \end{figure}%
    }

\newtheorem{conjecture}{Conjecture}

\newcommand{\bnfdef}{\mathrel{{\mathop:}{\mathop:}{=}}}

\newcommand{\optional}{^{?}}
\newcommand{\some}{^{+}}
\newcommand{\many}{^{*}}

\newcommand{\deriv}[2]{\frac{\;#1\;}{\;#2\;}}
\newcommand{\derivlinedone}{\\[1.5ex]}
\newcommand{\morederivs}{\qquad}
\newcommand{\nexthyp}{\quad}

\newcommand{\newkw}[1]
           {\expandafter\newcommand\csname kw#1\endcsname{\mathbf{#1}}}

\newkw{left}
\newkw{right}
\newkw{withenv}
\newkw{env}
\newkw{gate}
\newkw{defer}
\newkw{abort}
\newkw{trace}

\newkw{let}
\newkw{in}
\newkw{if}
\newkw{then}
\newkw{else}

\newcommand{\exlet}[2]{\kwlet \; #1 \; \kwin \; #2}
\newcommand{\exif}[3]{\kwif \; #1 \; \kwthen \; #2 \; \kwelse \; #3}
\newcommand{\exlam}[2]{\backslash \; #1 → #2}
\newcommand{\exclam}[2]{\# \; #1 → #2}
\newcommand{\exapp}[2]{#1 \; #2}
\newcommand{\exleft}[1]{\kwleft \; #1}
\newcommand{\exright}[1]{\kwright \; #1}
\newcommand{\extrace}[1]{\kwtrace \; #1}

\newcommand{\exwithenv}[1]{\kwwithenv \; #1}
\newcommand{\exgate}[1]{\kwgate \; #1}
\newcommand{\exdefer}[1]{\kwdefer \; #1}
\newcommand{\exabort}[1]{\kwabort \; #1}

\newcommand{\newnt}[1]
           {\expandafter\newcommand\csname#1\endcsname{\mathit{#1}}}

\newnt{Token}
\newnt{Keyword}
\newnt{Symbol}

\newnt{Prog}
\newnt{Expr}
\newnt{Pair}
\newnt{Left}
\newnt{Right}
\newnt{Zero}
\newnt{WithEnv}
\newnt{Env}
\newnt{Gate}
\newnt{Defer}
\newnt{Abort}
\newnt{Trace}

\newnt{Value}

\newnt{Type}
\newnt{FunType}
\newnt{PairType}
\newnt{ZeroType}
\newnt{TypeVar}

\newnt{Char}
\newnt{Letter}
\newnt{Digit}

\newnt{Ident}
\newnt{Str}
\newnt{Nat}

\newnt{Assign}
\newnt{Let}
\newnt{If}
\newnt{Lam}
\newnt{CLam}
\newnt{App}
\newnt{List}
\newnt{TNat}
\newnt{FNat}
\newnt{Var}

\newcommand{\internal}{_{\mathrm{i}}}

\title{Specification of the Stand-in Language}
\author{%
    Wolfgang Jeltsch\\
    \small Well-Typed LLP\\
    \small\texttt{wolfgang@well-typed.com}%
}

\begin{document}

\maketitle

\section{Introduction}

We present a formal specification of the Stand-in Language (SIL) by Sam
Griffin. Our specification closely resembles the version of the language
implemented in commit \texttt{966227a} of the GitHub repository
\texttt{sfultong/stand-in-language}.

We start our exposition by introducing some notation in
Section~\ref{notation}. Afterwards we provide the actual language
specification. SIL really consists of two languages: the internal
language and the surface language. While the former is the one for which
an operational semantics and a type system are defined, the latter
constitutes the user-facing part. We discuss the internal language in
Section~\ref{the-internal-language} and the surface language in
Section~\ref{the-surface-language}. In an
\hyperref[potential-problems]{appendix}, we state some potential
problems with the current language design and discuss possible solutions
to these problems.

\section{Notation}
\label{notation}

Throughout this document, we describe syntax using a variant of
Backus–Naur form. Our variant uses the following notations, listed here
in increasing order of precedence:
\begin{itemize}

\item

$∣$ denotes set union.

\item

$∖$ denotes set difference.

\item

Mere juxtaposition denotes concatenation.

\item

$\optional$, $\some$, and $\many$ denote optionality, repetition with at
least one occurrence, and arbitrary repetition, respectively.

\item

$⟨$~and~$⟩$ delimit subexpressions and are used for overriding default
precedence.\footnote{We do not use $($ and~$)$ for this purpose, since
they are part of some of the languages we want to describe.}

\item

Words in italics are nonterminals.

\end{itemize}

We introduce further custom notations for various things unrelated to
syntax. Since such notations are tied to specific parts of the
specification, we define them where they are needed.

\section{The Internal Language}
\label{the-internal-language}

The internal language is a low-level language, which in particular has
no built-in support for closures. It comes with an operational semantics
and a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-internal-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-internal-language}
defines the syntax of the language.
\begin{mathfigure}{token-syntax-of-the-internal-language}
                  {Token syntax of the internal language}
%
\begin{aligned}
%
\Token\internal   & \bnfdef \Keyword\internal ∣ \Symbol\internal     \\
\Keyword\internal & \bnfdef \kwleft ∣ \kwright ∣ \kwwithenv ∣ \kwenv
                            ∣ \kwgate ∣ \kwdefer ∣ \kwabort ∣
                            \kwtrace                                 \\
\Symbol\internal  & \bnfdef {\{} ∣ {,} ∣ {\}} ∣ ∅
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-internal-language}
                  {Syntax of the internal language}
%
\begin{aligned}
%
\Prog\internal    & \bnfdef \Expr\internal                      \\
\Expr\internal    & \bnfdef \Pair\internal ∣ \Left\internal ∣
                            \Right\internal ∣ \Zero\internal ∣
                            \WithEnv\internal ∣ \Env\internal ∣
                            \Gate\internal ∣ \Defer\internal ∣
                            \Abort\internal ∣ \Trace\internal   \\
\Pair\internal    & \bnfdef \{\Expr\internal, \Expr\internal\}  \\
\Left\internal    & \bnfdef \exleft{\Expr\internal}             \\
\Right\internal   & \bnfdef \exright{\Expr\internal}            \\
\Zero\internal    & \bnfdef ∅                                   \\
\WithEnv\internal & \bnfdef \exwithenv{\Expr\internal}          \\
\Env\internal     & \bnfdef \kwenv                              \\
\Gate\internal    & \bnfdef \exgate{\Expr\internal}             \\
\Defer\internal   & \bnfdef \exdefer{\Expr\internal}            \\
\Abort\internal   & \bnfdef \exabort{\Expr\internal}            \\
\Trace\internal   & \bnfdef \extrace{\Expr\internal}
%
\end{aligned}
%
\end{mathfigure}

\subsection{Semantics}
\label{internal-language-semantics}

Common functional programming languages express dependencies on external
data and function arguments by means of variables. The internal language
does not have variables technically, but the expression $\kwenv$ can be
considered a single variable. Following this view, an expression
$\exdefer{e}$ corresponds to an abstraction (“$λ$-expression”) $λ\kwenv
. e$. Because such an abstraction binds the only variable that exists,
the body of a $\kwdefer$ expression cannot refer to variable assignments
outside the $\kwdefer$ expression. This means that the internal language
does not support closures natively.

Evaluation turns arbitrary expressions into values. The syntax of values
is given by the following grammar:
\begin{equation*}
%
\Value \bnfdef \{\Value, \Value\} ∣ ∅ ∣ \exdefer{\Value}
%
\end{equation*}
Evaluation happens in an environment, which is the value that is used as
the evaluation result of $\kwenv$. Figure~\ref{operational-semantics}
defines a relation ${−} ⊢ {−} → {−} ⊆ \Value × \Expr × \Value$ that
constitutes the big-step (evaluation) semantics of the internal
language. A proposition $ℰ ⊢ e → v$ is true if and only if evaluating
the expression~$e$ in the environment~$ℰ$ may yield the value~$v$.
\begin{mathfigure}{operational-semantics}{Operational semantics}
%
\begin{gathered}
%
\deriv{ℰ ⊢ e₁ → v₁ \nexthyp ℰ ⊢ e₂ → v₂}
      {ℰ ⊢ \{e₁, e₂\} → \{v₁, v₂\}}
\derivlinedone
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{v₁, v₂\}}
      {ℰ ⊢ \exleft{e} → v₁}
\derivlinedone
\deriv{ℰ ⊢ e → v \nexthyp ∀v₁ \; v₂ . v ≠ \{v₁, v₂\}}
      {ℰ ⊢ \exleft{e} → ∅}
%
\end{gathered}
\morederivs
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{v₁, v₂\}}
      {ℰ ⊢ \exright{e} → v₂}
\derivlinedone
\deriv{ℰ ⊢ e → v \nexthyp ∀v₁ \; v₂ . v ≠ \{v₁, v₂\}}
      {ℰ ⊢ \exright{e} → ∅}
%
\end{gathered}
\derivlinedone
\deriv{}
      {ℰ ⊢ ∅ → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → \{\exdefer{e′}, v\} \nexthyp v ⊢ e′ → v′}
      {ℰ ⊢ \exwithenv{e} → v′}
\derivlinedone
\deriv{}
      {ℰ ⊢ \kwenv → ℰ}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exgate{e} → \exdefer{\exleft{\kwenv}}}
\morederivs
\deriv{ℰ ⊢ e → v \nexthyp v ≠ ∅}
      {ℰ ⊢ \exgate{e} → \exdefer{\exright{\kwenv}}}
\derivlinedone
\deriv{}
      {ℰ ⊢ \exdefer{e} → \exdefer{e}}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exabort{e} → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → v}
      {ℰ ⊢ \extrace{e} → v}
%
\end{gathered}
%
\end{mathfigure}

The relation ${−} ⊢ {−} → {−}$ is in fact a partial function. This means
that evaluation is deterministic: it either fails or leads to a uniquely
defined value.

The semantics only covers the pure aspects of execution. The $\kwtrace$
construct is actually impure, as it outputs diagnostic information. Our
semantics ignores that, treating any expression of the form
$\extrace{e}$ like~$e$.

\subsection{Type System}

The type system of the internal language does not distinguish between
different types of nested pairs. Instead it considers any nested pair to
be an inhabitant of any nested pair type.

Figure~\ref{type-syntax} defines the syntax of types, and
Figure~\ref{equivalence-of-types} defines an equivalence relation on
types that identifies all nested pair types. Based on these things,
Figure~\ref{typing-rules-for-unevaluated-expressions} defines the typing
relation ${−} ⊢ {−} : {−} ⊆ \Type × \Expr × \Type$. A proposition $𝒯 ⊢ e
: τ$ is true if and only if the expression~$e$ has type~$τ$ provided
that the environment has type~$𝒯$.
\begin{mathfigure}{type-syntax}{Type syntax}
%
\begin{aligned}
%
\Type     & \bnfdef \Type₀                                        \\
\Type₀    & \bnfdef \FunType ∣ \Type₁                             \\
\FunType  & \bnfdef \Type₁ ⇒ \Type₀                               \\
\Type₁    & \bnfdef \PairType ∣ \ZeroType ∣ \TypeVar ∣ (\Type₀)   \\
\PairType & \bnfdef \{\Type₀, \Type₀\}                            \\
\ZeroType & \bnfdef ∅                                             \\
\TypeVar  & \bnfdef \Letter
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{equivalence-of-types}{Equivalence of types}
%
\begin{gathered}
%
\deriv{}{∅ ≈ \{∅, ∅\}}
\derivlinedone
\deriv{τ₁ ≈ τ₁′ \nexthyp τ₂ ≈ τ₂'}{τ₁ ⇒ τ₂ ≈ τ₁′ ⇒ τ₂′}
\morederivs
\deriv{τ₁ ≈ τ₁′ \nexthyp τ₂ ≈ τ₂'}{\{τ₁, τ₂\} ≈ \{τ₁′, τ₂′\}}
\morederivs
\deriv{}{∅ ≈ ∅}
\morederivs
\deriv{α ∈ \TypeVar}{α ≈ α}
\derivlinedone
\deriv{τ₁ ≈ τ₂}{τ₂ ≈ τ₁}
\morederivs
\deriv{τ₁ ≈ τ₂ \nexthyp τ₂ ≈ τ₃}{τ₁ ≈ τ₃}
%
\end{gathered}
%
\end{mathfigure}
\begin{mathfigure}{typing-rules-for-unevaluated-expressions}
                  {Typing rules for unevaluated expressions}
%
\begin{gathered}
%
\deriv{𝒯 ⊢ e₁ : τ₁ \nexthyp 𝒯 ⊢ e₂ : τ₂}{𝒯 ⊢ \{e₁, e₂\} : \{τ₁, τ₂\}}
\derivlinedone
\deriv{𝒯 ⊢ e : \{τ₁, τ₂\}}{𝒯 ⊢ \exleft{e} : τ₁}
\morederivs
\deriv{𝒯 ⊢ e : \{τ₁, τ₂\}}{𝒯 ⊢ \exright{e} : τ₂}
\derivlinedone
\deriv{}{𝒯 ⊢ ∅ : ∅}
\derivlinedone
\deriv{𝒯 ⊢ e : \{τ₁ ⇒ τ₂, τ₁\}}{𝒯 ⊢ \exwithenv{e} : τ₂}
\derivlinedone
\deriv{}{𝒯 ⊢ \kwenv : 𝒯}
\derivlinedone
\deriv{𝒯 ⊢ e : ∅}{𝒯 ⊢ \exgate{e} : \{τ, τ\} ⇒ τ}
\derivlinedone
\deriv{τ₁ ⊢ e : τ₂}{𝒯 ⊢ \exdefer{e} : τ₁ ⇒ τ₂}
\derivlinedone
\deriv{𝒯 ⊢ e : ∅}{𝒯 ⊢ \exabort{e} : ∅}
\derivlinedone
\deriv{𝒯 ⊢ e : τ}{𝒯 ⊢ \extrace{e} : τ}
\derivlinedone
\deriv{τ₁ ≈ τ₂ \nexthyp 𝒯 ⊢ e : τ₁}{𝒯 ⊢ e : τ₂}
%
\end{gathered}
%
\end{mathfigure}
\begin{mathfigure}{typing-rules-for-evaluated-expressions}
                  {Typing rules for evaluated expressions}
%
\begin{gathered}
%
\deriv{e₁ : τ₁ \nexthyp e₂ : τ₂}{\{e₁, e₂\} : \{τ₁, τ₂\}}
\derivlinedone
\deriv{}{∅ : ∅}
\derivlinedone
\deriv{𝒯 ⊢ e : τ}{e : 𝒯 ⇒ τ}
\derivlinedone
\deriv{τ₁ ≈ τ₂ \nexthyp e : τ₁}{e : τ₂}
%
\end{gathered}
%
\end{mathfigure}

\begin{conjecture}[Type preservation]

If $ℰ : 𝒯$, $𝒯 ⊢ e : τ$, and $ℰ ⊢ e → v$, then $𝒯′ ⊢ v : τ$ for any
type~$𝒯'$.

\end{conjecture}

\section{The Surface Language}
\label{the-surface-language}

The surface language is a high-level language, which in particular has
support for closures. Programs in the surface language are translated to
the internal language using a process called desugaring. The surface
language does not have an operational semantics of its own; a surface
language expression is evaluated by first desugaring it and then
evaluating the resulting internal expression. Currently, the surface
language does not have a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-surface-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-surface-language}
defines the syntax of the language. The nonterminals $\CLam$, $\TNat$,
and $\FNat$ stand for “complete lambda”, “tuple natural”, and “function
natural”, respectively.
\begin{mathfigure}{token-syntax-of-the-surface-language}
                  {Token syntax of the surface language}
%
\begin{aligned}
%
\Token   & \bnfdef \Ident ∣ \Str ∣ \Nat ∣ \Keyword ∣ \Symbol       \\
\Ident   & \bnfdef \Letter⟨\Letter ∣ \Digit ∣ \_ ∣ {′}⟩\many ∖
                   \Keyword                                        \\
\Str     & \bnfdef \text{“}\Char\many\text{”}                      \\
\Nat     & \bnfdef \Digit\some                                     \\
\Keyword & \bnfdef \kwlet ∣ \kwin ∣ \kwif ∣ \kwthen ∣ \kwelse ∣
                   \kwleft ∣ \kwright ∣ \kwtrace                   \\
\Symbol  & \bnfdef {:} ∣ {=} ∣ \backslash ∣ {→} ∣ \# ∣ {[} ∣ {]} ∣
                   {,} ∣ \$ ∣ {\{} ∣ {\}} ∣ {(} ∣ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-surface-language}
                  {Syntax of the surface language}
%
\begin{aligned}
%
\Prog   & \bnfdef \Assign\some                                   \\
\Assign & \bnfdef \Ident \; ⟨{:} \; \Expr₀⟩\optional = \Expr₀    \\
\Expr₀  & \bnfdef \Let ∣ \If ∣ \Lam ∣ \CLam ∣ \Expr₁             \\
\Let    & \bnfdef \exlet{\Assign\many}{\Expr₀}                   \\
\If     & \bnfdef \exif{\Expr₀}{\Expr₀}{\Expr₀}                  \\
\Lam    & \bnfdef \exlam{\Var\some}{\Expr₀}                      \\
\CLam   & \bnfdef \exclam{\Var\some}{\Expr₀}                     \\
\Expr₁  & \bnfdef \App ∣ \Expr₂                                  \\
\App    & \bnfdef \exapp{\Expr₁}{\Expr₂}                         \\
\Expr₂  & \bnfdef \List ∣ \Str ∣ \TNat ∣ \FNat ∣ \Pair ∣ \Left ∣
                  \Right ∣ \Trace ∣ \Var ∣ (\Expr₀)              \\
\List   & \bnfdef [] ∣ [\Expr₀ ⟨, \Expr₀⟩\many]                  \\
\TNat   & \bnfdef \Nat                                           \\
\FNat   & \bnfdef \$\Nat                                         \\
\Pair   & \bnfdef \{\Expr₀, \Expr₀\}                             \\
\Left   & \bnfdef \exleft{\Expr₂}                                \\
\Right  & \bnfdef \exright{\Expr₂}                               \\
\Trace  & \bnfdef \extrace{\Expr₂}                               \\
\Var    & \bnfdef \Ident                                         \\
%
\end{aligned}
%
\end{mathfigure}
%NOTE: The vertical bars in the grammar source are not the ASCII
%      character U+007C VERTICAL LINE but the character U+2223 DIVIDES,
%      which the ucs package translates into \mid. This is important to
%      get the proper spacing.

\subsection{Desugaring}

For defining desugaring, we introduce the following notations:
\begin{itemize}

\item

$⟨e⟩_{x ↦ e′}$ means the expression~$e$ with free occurrences of~$x$
replaced by~$e′$.

\item

$c_{\#}$ means the natural number literal that represents the code of
the character~$c$.

\item

$n_{+}$ means the natural number literal that represents the successor
of~$n$.

\item

$f^{n} x$ means the n-fold application of~$f$ to~$x$, that is,
$\exapp{f}{\exapp{…}{\exapp{f}{\exapp{x}}}}$ where $f$ occurs $n$~times.

\end{itemize}

Desugaring of an expression happens in a context, which is the list of
variables that are in scope, with variables bound closer to the
expression being listed later. We write $ε$ for the empty context and $Δ
⊳ x$ for the context~$Δ$ extended by~$x$. An internal expression
obtained by desugaring in a context~$Δ$ is supposed to be evaluated in
the environment $\{e_{n}, \{e_{n - 1}, \{…, \{e₁, ∅\}…\}\}\}$ where
each~$e_{i}$ is the value of the $i$-th variable in~$Δ$.

We introduce a helper function~$ρ : \Var\some × \Var → \Expr\internal$
such that $ρ(Δ, x)$ yields an internal expression that is evaluated to a
pair whose first element is the value of~$x$. The definition of~$ρ$ is
as follows:
\begin{equation}
%
ρ(Δ ⊳ x, y) = \begin{cases}
                  \kwenv            & \text{if $x = y$} \\
                  \exright{ρ(Δ, y)} & \text{if $x ≠ y$}
              \end{cases}
%
\end{equation}

Figure~\ref{desugaring-of-expressions} defines a function $⌊−⌋_{−} :
\Expr × \Var\many → \Expr\internal$ that describes desugaring of
expressions. A term $⌊e⌋_{Δ}$ gives the internal expression that
corresponds to the surface expression~$e$ in the context~$Δ$. Based on
$⌊−⌋_{−}$ we define a function $⌊−⌋ : \Prog → \Prog\internal$ that
describes desugaring of programs:
\begin{equation}
%
⌊p⌋ = ⌊\exlet{p}{\mathit{main}}⌋_{ε}
%
\end{equation}
\begin{mathfigure}{desugaring-of-expressions}{Desugaring of expressions}
%
\newcommand{\nextline}{\\ & \mathrel{\phantom{=}}}
\newcommand{\exapprhs}{
    \kwwithenv
    \nextline
    \quad \kwwithenv \; \{
    \nextline
    \quad\quad \exdefer{
                   \{
                       \exleft{\exright{\kwenv}},
                       \{\exleft{\kwenv}, \exright{\exright{\kwenv}}\}
                   \}
               },
    \nextline
    \quad\quad \{⌊e₂⌋_{Δ}, ⌊e₁⌋_{Δ}\}
    \nextline
    \quad \}
}
%
\begin{aligned}
%
⌊\kwlet \; \kwin \; e⌋_{Δ}
    & = ⌊e⌋_{Δ}                                                   \\
⌊\exlet{x = e′ : e″ \; \bar{a}}{e}⌋_{Δ}
     & = ⌊\exlet{x = e′ \; \bar{a}}{e}⌋_{Δ}                       \\
⌊\exlet{x = e′ \; \bar{a}}{e}⌋_{Δ}
     & = ⌊⟨\exlet{\bar{a}}{e}⟩_{x ↦ e′}⌋_{Δ}                      \\
⌊\exif{e}{e₁}{e₂}⌋_{Δ}
     & = \exwithenv{\{\exgate{⌊e⌋_{Δ}}, \{⌊e₁⌋_{Δ}, ⌊e₂⌋_{Δ}\}\}} \\
⌊\exlam{\bar{x}}{e}⌋_{Δ}
     & = \{\exdefer{⌊e⌋_{Δ ∘ \bar{x}}}, \kwenv\}                  \\
⌊\exclam{\bar{x}}{e}⌋_{Δ}
     & = \{\exdefer{⌊e⌋_{\bar{x}}}, ∅\}                           \\
⌊\exapp{e₁}{e₂}⌋_{Δ}
     & = \exapprhs                                                \\
⌊[]⌋_{Δ}
     & = ∅                                                        \\
⌊[e, l]⌋_{Δ}
     & = \{⌊e⌋_{Δ}, ⌊[l]⌋_{Δ}\}                                   \\
⌊\text{“}\,\text{”}⌋_{Δ}
     & = ∅                                                        \\
⌊\text{“}c\bar{c}\text{”}⌋_{Δ}
     & = \{⌊c_{\#}⌋_{Δ}, ⌊\text{“}\bar{c}\text{”}⌋_{Δ}\}          \\
⌊0⌋_{Δ}
     & = ∅                                                        \\
⌊n_{+}⌋_{Δ}
     & = \{⌊n⌋_{Δ}, ∅\}                                           \\
⌊\$n⌋_{Δ}
     & = ⌊\exclam{f \; x}{f^{n} x}⌋_{Δ}                           \\
⌊\{e₁, e₂\}⌋_{Δ}
     & = \{⌊e₁⌋_{Δ}, ⌊e₂⌋_{Δ}\}                                   \\
⌊\exleft{e}⌋_{Δ}
     & = \exleft{⌊e⌋_{Δ}}                                         \\
⌊\exright{e}⌋_{Δ}
     & = \exright{⌊e⌋_{Δ}}                                        \\
⌊\extrace{e}⌋_{Δ}
     & = \extrace{⌊e⌋_{Δ}}                                        \\
⌊x⌋_{Δ}
     & = \exleft{ρ(Δ, x)}                                         \\
⌊(e)⌋_{Δ}
     & = ⌊e⌋_{Δ}
%
\end{aligned}
%
\end{mathfigure}

\appendix

\section{Potential Problems}
\label{potential-problems}

There are some potential problems with the described version of SIL,
which we describe in the following sections.

\subsection{Expressivity}

It looks like SIL programs cannot use any recursion scheme that goes
beyond primitive recursion. The SIL prelude is supposed to provide
several functions that actually need more powerful recursion schemes.
They are approximated using primitive recursion, effectively by starting
with a generally recursive implementation and then placing an upper
bound on the recursion depth. This makes code that uses these functions
difficult to write and reason about.

\subsection{Efficiency}

The two representations of natural numbers (nested pairs and church
encodings) and the representation of environments (nested pairs) are
space and time inefficient without optimization. Since these
representations are on a considerably lower level than the things they
represent, it is probably difficult to rectify their inefficiencies
using domain-specific optimizations.

\subsection{Precision of Types}

In the internal language all nested pairs have the same type. As a
result, all tuple representations of natural numbers have the same type,
which seems sensible. However, in other situations valuable type
information may get lost.

\end{document}

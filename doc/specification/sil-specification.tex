\documentclass{scrartcl}

\deffootnote{1em}{1em}{\textsuperscript{\thefootnotemark}}

\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}

\usepackage
    [bitstream-charter,greekuppercase=italicized]
    {mathdesign}
\renewcommand{\sfdefault}{fvs}
\renewcommand{\ttdefault}{fvm}

\usepackage[utf8x]{inputenc}

\SetUnicodeOption{mathletters}

\PreloadUnicodePage{3}
\PreloadUnicodePage{32}
\PreloadUnicodePage{33}
\PreloadUnicodePage{34}
\PreloadUnicodePage{35}
\PreloadUnicodePage{39}
\PreloadUnicodePage{468}

\DeclareMathSymbol{.}{\mathrel}{letters}{"3A}

\usepackage{microtype}

\usepackage{hyperref}

\usepackage{xcolor}

\colorlet{link}{violet}
\colorlet{cite}{brown!70!red!70!black}
\colorlet{url}{blue!80!black}
\hypersetup{colorlinks=true,linkcolor=link,citecolor=cite,urlcolor=url}

\usepackage{amsmath}
\usepackage{amsthm}

\newenvironment{mathfigure}[2]
    {%
        \begin{figure}
        \newcommand{\figurelabel}{#1}
        \newcommand{\figurecaption}{#2}
        \centering
        \begin{math}
    }
    {
        \end{math}
        \caption{\figurecaption}
        \label{\figurelabel}
        \end{figure}%
    }

\newtheorem{conjecture}{Conjecture}

\newcommand{\bnfdef}{\mathrel{{\mathop:}{\mathop:}{=}}}

\newcommand{\optional}{^{?}}
\newcommand{\some}{^{+}}
\newcommand{\many}{^{*}}

\newcommand{\deriv}[2]{\frac{\;#1\;}{\;#2\;}}
\newcommand{\derivlinedone}{\\[1.5ex]}
\newcommand{\morederivs}{\qquad}
\newcommand{\nexthyp}{\quad}

\newcommand{\newkw}[1]
           {\expandafter\newcommand\csname kw#1\endcsname{\mathbf{#1}}}

\newkw{left}
\newkw{right}
\newkw{withenv}
\newkw{env}
\newkw{gate}
\newkw{defer}
\newkw{abort}
\newkw{trace}

\newkw{let}
\newkw{in}
\newkw{if}
\newkw{then}
\newkw{else}

\newcommand{\exlet}[2]{\kwlet \; #1 \; \kwin \; #2}
\newcommand{\exif}[3]{\kwif \; #1 \; \kwthen \; #2 \; \kwelse \; #3}
\newcommand{\exlam}[2]{\backslash \; #1 â†’ #2}
\newcommand{\exclam}[2]{\# \; #1 â†’ #2}
\newcommand{\exapp}[2]{#1 \; #2}
\newcommand{\exleft}[1]{\kwleft \; #1}
\newcommand{\exright}[1]{\kwright \; #1}
\newcommand{\extrace}[1]{\kwtrace \; #1}

\newcommand{\exwithenv}[1]{\kwwithenv \; #1}
\newcommand{\exgate}[1]{\kwgate \; #1}
\newcommand{\exdefer}[1]{\kwdefer \; #1}
\newcommand{\exabort}[1]{\kwabort \; #1}

\newcommand{\newnt}[1]
           {\expandafter\newcommand\csname#1\endcsname{\mathit{#1}}}

\newnt{Token}
\newnt{Keyword}
\newnt{Symbol}

\newnt{Prog}
\newnt{Expr}
\newnt{Pair}
\newnt{Left}
\newnt{Right}
\newnt{Zero}
\newnt{WithEnv}
\newnt{Env}
\newnt{Gate}
\newnt{Defer}
\newnt{Abort}
\newnt{Trace}

\newnt{Type}
\newnt{FunType}
\newnt{PairType}
\newnt{ZeroType}
\newnt{TypeVar}

\newnt{Char}
\newnt{Letter}
\newnt{Digit}

\newnt{Ident}
\newnt{Str}
\newnt{Nat}

\newnt{Assign}
\newnt{Let}
\newnt{If}
\newnt{Lam}
\newnt{CLam}
\newnt{App}
\newnt{List}
\newnt{TNat}
\newnt{FNat}
\newnt{Var}

\newcommand{\internal}{_{\mathrm{i}}}

\title{Specification of the Stand-in Language}
\author{%
    Wolfgang Jeltsch\\
    \small Well-Typed LLP\\
    \small\texttt{wolfgang@well-typed.com}%
}

\begin{document}

\maketitle

\section{Introduction}

We present a formal specification of the Stand-in Language (SIL) by Sam
Griffin. Our specification closely resembles the version of the language
implemented in commit \texttt{966227a} of the GitHub repository
\texttt{sfultong/stand-in-language}.

We start our exposition by introducing some notation in
Section~\ref{notation}. Afterwards we provide the actual language
specification. SIL really consists of two languages: the internal
language and the surface language. While the former is the one for which
an operational semantics and a type system are defined, the latter
constitutes the user-facing part. We discuss the internal language in
Section~\ref{the-internal-language} and the surface language in
Section~\ref{the-surface-language}. In an
\hyperref[potential-problems]{appendix}, we state some potential
problems with the current language design and discuss possible solutions
to these problems.

\section{Notation}
\label{notation}

Throughout this document, we describe syntax using a variant of
Backusâ€“Naur form. Our variant uses the following notations, listed here
in increasing order of precedence:
\begin{itemize}

\item

$âˆ£$ denotes set union.

\item

$âˆ–$ denotes set difference.

\item

Mere juxtaposition denotes concatenation.

\item

$\optional$, $\some$, and $\many$ denote optionality, repetition with at
least one occurrence, and arbitrary repetition, respectively.

\item

$âŸ¨$~and~$âŸ©$ delimit subexpressions and are used for overriding default
precedence.\footnote{We do not use $($ and~$)$ for this purpose, since
they are part of some of the languages we want to describe.}

\item

Words in italics are nonterminals.

\end{itemize}

We introduce further custom notations for various things unrelated to
syntax. Since such notations are tied to specific parts of the
specification, we define them where they are needed.

\section{The Internal Language}
\label{the-internal-language}

The internal language is a low-level language, which in particular has
no built-in support for closures. It comes with an operational semantics
and a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-internal-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-internal-language}
defines the syntax of the language.
\begin{mathfigure}{token-syntax-of-the-internal-language}
                  {Token syntax of the internal language}
%
\begin{aligned}
%
\Token\internal   & \bnfdef \Keyword\internal âˆ£ \Symbol\internal     \\
\Keyword\internal & \bnfdef \kwleft âˆ£ \kwright âˆ£ \kwwithenv âˆ£ \kwenv
                            âˆ£ \kwgate âˆ£ \kwdefer âˆ£ \kwabort âˆ£
                            \kwtrace                                 \\
\Symbol\internal  & \bnfdef {\{} âˆ£ {,} âˆ£ {\}} âˆ£ âˆ…
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-internal-language}
                  {Syntax of the internal language}
%
\begin{aligned}
%
\Prog\internal    & \bnfdef \Expr\internal                      \\
\Expr\internal    & \bnfdef \Pair\internal âˆ£ \Left\internal âˆ£
                            \Right\internal âˆ£ \Zero\internal âˆ£
                            \WithEnv\internal âˆ£ \Env\internal âˆ£
                            \Gate\internal âˆ£ \Defer\internal âˆ£
                            \Abort\internal âˆ£ \Trace\internal   \\
\Pair\internal    & \bnfdef \{\Expr\internal, \Expr\internal\}  \\
\Left\internal    & \bnfdef \exleft{\Expr\internal}             \\
\Right\internal   & \bnfdef \exright{\Expr\internal}            \\
\Zero\internal    & \bnfdef âˆ…                                   \\
\WithEnv\internal & \bnfdef \exwithenv{\Expr\internal}          \\
\Env\internal     & \bnfdef \kwenv                              \\
\Gate\internal    & \bnfdef \exgate{\Expr\internal}             \\
\Defer\internal   & \bnfdef \exdefer{\Expr\internal}            \\
\Abort\internal   & \bnfdef \exabort{\Expr\internal}            \\
\Trace\internal   & \bnfdef \extrace{\Expr\internal}
%
\end{aligned}
%
\end{mathfigure}

\subsection{Semantics}
\label{internal-language-semantics}

Common functional programming languages express dependencies on external
data and function arguments by means of variables. The internal language
does not have variables technically, but the expression $\kwenv$ can be
considered a single variable. Following this view, an expression
$\exdefer{e}$ corresponds to an abstraction (â€œ$Î»$-expressionâ€) $Î»\kwenv
. e$. Because such an abstraction binds the only variable that exists,
the body of a $\kwdefer$ expression cannot refer to variable assignments
outside the $\kwdefer$ expression. This means that the internal language
does not support closures natively.

It is customary in the functional programming world to evaluate function
expressions to abstractions. In our context, where $\kwenv$ is the only
variable, this would always lead to abstractions that bind $\kwenv$.
Since such abstractions correspond to $\kwdefer$ expressions, we could
use these as the evaluation results of function expressions. However, we
deviate from this approach slightly in order to conform to the
implementation. Instead of yielding an expression $\exdefer{e}$, we just
yield its body~$e$.

Expression evaluation happens in an environment. The environment is an
evaluated expression that characterizes the value of $\kwenv$.
Figure~\ref{operational-semantics} defines a relation ${âˆ’} âŠ¢ {âˆ’} â†’ {âˆ’} âŠ†
\Expr Ã— \Expr Ã— \Expr$ that constitutes the big-step (evaluation)
semantics of the internal language. A proposition $â„° âŠ¢ e â†’ eâ€²$ is true
if and only if evaluating the expression~$e$ in the environment~$â„°$ may
yield the expression~$eâ€²$.
\begin{mathfigure}{operational-semantics}{Operational semantics}
%
\begin{gathered}
%
\deriv{â„° âŠ¢ eâ‚ â†’ eâ‚â€² \nexthyp â„° âŠ¢ eâ‚‚ â†’ eâ‚‚â€²}
      {â„° âŠ¢ \{eâ‚, eâ‚‚\} â†’ \{eâ‚â€², eâ‚‚â€²\}}
\derivlinedone
\begin{gathered}
%
\deriv{â„° âŠ¢ e â†’ \{eâ‚, eâ‚‚\}}
      {â„° âŠ¢ \exleft{e} â†’ eâ‚}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ eâ€² \nexthyp âˆ€eâ‚ \; eâ‚‚ . eâ€²â‰  \{eâ‚, eâ‚‚\}}
      {â„° âŠ¢ \exleft{e} â†’ âˆ…}
%
\end{gathered}
\morederivs
\begin{gathered}
%
\deriv{â„° âŠ¢ e â†’ \{eâ‚, eâ‚‚\}}
      {â„° âŠ¢ \exright{e} â†’ eâ‚‚}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ eâ€² \nexthyp âˆ€eâ‚ \; eâ‚‚ . eâ€²â‰  \{eâ‚, eâ‚‚\}}
      {â„° âŠ¢ \exright{e} â†’ âˆ…}
%
\end{gathered}
\derivlinedone
\deriv{}
      {â„° âŠ¢ âˆ… â†’ âˆ…}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ \{eâ‚, eâ‚‚\} \nexthyp eâ‚‚ âŠ¢ eâ‚ â†’ eâ€²}
      {â„° âŠ¢ \exwithenv{e} â†’ eâ€²}
\derivlinedone
\deriv{}
      {â„° âŠ¢ \kwenv â†’ â„°}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ âˆ…}
      {â„° âŠ¢ \exgate{e} â†’ \exleft{\kwenv}}
\morederivs
\deriv{â„° âŠ¢ e â†’ eâ€² \nexthyp eâ€² â‰  âˆ…}
      {â„° âŠ¢ \exgate{e} â†’ \exright{\kwenv}}
\derivlinedone
\deriv{}
      {â„° âŠ¢ \exdefer{e} â†’ e}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ âˆ…}
      {â„° âŠ¢ \exabort{e} â†’ âˆ…}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ eâ€²}
      {â„° âŠ¢ \extrace{e} â†’ eâ€²}
%
\end{gathered}
%
\end{mathfigure}

The relation ${âˆ’} âŠ¢ {âˆ’} â†’ {âˆ’}$ is in fact a partial function. This means
that evaluation is deterministic: it either fails or leads to a uniquely
defined expression.

The semantics only covers the pure aspects of execution. The $\kwtrace$
construct is actually impure, as it outputs diagnostic information. Our
semantics ignores that, treating any expression of the form
$\extrace{e}$ like~$e$.

\subsection{Type System}

The type system of the internal language is special in two ways:
\begin{itemize}

\item

There are two typing relations, one for unevaluated and one for
evaluated expressions. This is necessary, because function expressions
are evaluated to expressions that do not describe the functions
themselves but their results. If we would use the same typing relation
for unevaluated and evaluated expressions, the type of an expression
could change through evaluation.

\item

The type system does not distinguish between different types of nested
pairs. Each nested pair type contains all nested pairs.

\end{itemize}

Figure~\ref{type-syntax} defines the syntax of types, and
Figure~\ref{equivalence-of-types} defines an equivalence relation on
types that identifies all nested pair types. Based on that,
Figure~\ref{typing-rules-for-unevaluated-expressions} defines the typing
relation ${âˆ’} âŠ¢ {âˆ’} : {âˆ’} âŠ† \Type Ã— \Expr Ã— \Type$ for unevaluated
expressions. A proposition $ğ’¯ âŠ¢ e : Ï„$ is true if and only if the
unevaluated expression~$e$ has type~$Ï„$ provided that the environment
has type~$ğ’¯$. Finally,
Figure~\ref{typing-rules-for-evaluated-expressions} defines the typing
relation ${âˆ’} : {âˆ’} âŠ† \Expr Ã— \Type$ for evaluated expressions.
\begin{mathfigure}{type-syntax}{Type syntax}
%
\begin{aligned}
%
\Type     & \bnfdef \Typeâ‚€                                        \\
\Typeâ‚€    & \bnfdef \FunType âˆ£ \Typeâ‚                             \\
\FunType  & \bnfdef \Typeâ‚ â‡’ \Typeâ‚€                               \\
\Typeâ‚    & \bnfdef \PairType âˆ£ \ZeroType âˆ£ \TypeVar âˆ£ (\Typeâ‚€)   \\
\PairType & \bnfdef \{\Typeâ‚€, \Typeâ‚€\}                            \\
\ZeroType & \bnfdef âˆ…                                             \\
\TypeVar  & \bnfdef \Letter
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{equivalence-of-types}{Equivalence of types}
%
\begin{gathered}
%
\deriv{}{âˆ… â‰ˆ \{âˆ…, âˆ…\}}
\derivlinedone
\deriv{Ï„â‚ â‰ˆ Ï„â‚â€² \nexthyp Ï„â‚‚ â‰ˆ Ï„â‚‚'}{Ï„â‚ â‡’ Ï„â‚‚ â‰ˆ Ï„â‚â€² â‡’ Ï„â‚‚â€²}
\morederivs
\deriv{Ï„â‚ â‰ˆ Ï„â‚â€² \nexthyp Ï„â‚‚ â‰ˆ Ï„â‚‚'}{\{Ï„â‚, Ï„â‚‚\} â‰ˆ \{Ï„â‚â€², Ï„â‚‚â€²\}}
\morederivs
\deriv{}{âˆ… â‰ˆ âˆ…}
\morederivs
\deriv{Î± âˆˆ \TypeVar}{Î± â‰ˆ Î±}
\derivlinedone
\deriv{Ï„â‚ â‰ˆ Ï„â‚‚}{Ï„â‚‚ â‰ˆ Ï„â‚}
\morederivs
\deriv{Ï„â‚ â‰ˆ Ï„â‚‚ \nexthyp Ï„â‚‚ â‰ˆ Ï„â‚ƒ}{Ï„â‚ â‰ˆ Ï„â‚ƒ}
%
\end{gathered}
%
\end{mathfigure}
\begin{mathfigure}{typing-rules-for-unevaluated-expressions}
                  {Typing rules for unevaluated expressions}
%
\begin{gathered}
%
\deriv{ğ’¯ âŠ¢ eâ‚ : Ï„â‚ \nexthyp ğ’¯ âŠ¢ eâ‚‚ : Ï„â‚‚}{ğ’¯ âŠ¢ \{eâ‚, eâ‚‚\} : \{Ï„â‚, Ï„â‚‚\}}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : \{Ï„â‚, Ï„â‚‚\}}{ğ’¯ âŠ¢ \exleft{e} : Ï„â‚}
\morederivs
\deriv{ğ’¯ âŠ¢ e : \{Ï„â‚, Ï„â‚‚\}}{ğ’¯ âŠ¢ \exright{e} : Ï„â‚‚}
\derivlinedone
\deriv{}{ğ’¯ âŠ¢ âˆ… : âˆ…}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : \{Ï„â‚ â‡’ Ï„â‚‚, Ï„â‚\}}{ğ’¯ âŠ¢ \exwithenv{e} : Ï„â‚‚}
\derivlinedone
\deriv{}{ğ’¯ âŠ¢ \kwenv : ğ’¯}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : âˆ…}{ğ’¯ âŠ¢ \exgate{e} : \{Ï„, Ï„\} â‡’ Ï„}
\derivlinedone
\deriv{Ï„â‚ âŠ¢ e : Ï„â‚‚}{ğ’¯ âŠ¢ \exdefer{e} : Ï„â‚ â‡’ Ï„â‚‚}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : âˆ…}{ğ’¯ âŠ¢ \exabort{e} : âˆ…}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : Ï„}{ğ’¯ âŠ¢ \extrace{e} : Ï„}
\derivlinedone
\deriv{Ï„â‚ â‰ˆ Ï„â‚‚ \nexthyp ğ’¯ âŠ¢ e : Ï„â‚}{ğ’¯ âŠ¢ e : Ï„â‚‚}
%
\end{gathered}
%
\end{mathfigure}
\begin{mathfigure}{typing-rules-for-evaluated-expressions}
                  {Typing rules for evaluated expressions}
%
\begin{gathered}
%
\deriv{eâ‚ : Ï„â‚ \nexthyp eâ‚‚ : Ï„â‚‚}{\{eâ‚, eâ‚‚\} : \{Ï„â‚, Ï„â‚‚\}}
\derivlinedone
\deriv{}{âˆ… : âˆ…}
\derivlinedone
\deriv{ğ’¯ âŠ¢ e : Ï„}{e : ğ’¯ â‡’ Ï„}
\derivlinedone
\deriv{Ï„â‚ â‰ˆ Ï„â‚‚ \nexthyp e : Ï„â‚}{e : Ï„â‚‚}
%
\end{gathered}
%
\end{mathfigure}

\begin{conjecture}[Type preservation]

If $â„° : ğ’¯$, $ğ’¯ âŠ¢ e : Ï„$, and $â„° âŠ¢ e â†’ eâ€²$, then $eâ€² : Ï„$.

\end{conjecture}

\section{The Surface Language}
\label{the-surface-language}

The surface language is a high-level language, which in particular has
support for closures. Programs in the surface language are translated to
the internal language using a process called desugaring. The surface
language does not have an operational semantics of its own; a surface
language expression is evaluated by first desugaring it and then
evaluating the resulting internal expression. Currently, the surface
language does not have a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-surface-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-surface-language}
defines the syntax of the language. The nonterminals $\CLam$, $\TNat$,
and $\FNat$ stand for â€œcomplete lambdaâ€, â€œtuple naturalâ€, and â€œfunction
naturalâ€, respectively.
\begin{mathfigure}{token-syntax-of-the-surface-language}
                  {Token syntax of the surface language}
%
\begin{aligned}
%
\Token   & \bnfdef \Ident âˆ£ \Str âˆ£ \Nat âˆ£ \Keyword âˆ£ \Symbol       \\
\Ident   & \bnfdef \LetterâŸ¨\Letter âˆ£ \Digit âˆ£ \_ âˆ£ {â€²}âŸ©\many âˆ–
                   \Keyword                                        \\
\Str     & \bnfdef \text{â€œ}\Char\many\text{â€}                      \\
\Nat     & \bnfdef \Digit\some                                     \\
\Keyword & \bnfdef \kwlet âˆ£ \kwin âˆ£ \kwif âˆ£ \kwthen âˆ£ \kwelse âˆ£
                   \kwleft âˆ£ \kwright âˆ£ \kwtrace                   \\
\Symbol  & \bnfdef {:} âˆ£ {=} âˆ£ \backslash âˆ£ {â†’} âˆ£ \# âˆ£ {[} âˆ£ {]} âˆ£
                   {,} âˆ£ \$ âˆ£ {\{} âˆ£ {\}} âˆ£ {(} âˆ£ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-surface-language}
                  {Syntax of the surface language}
%
\begin{aligned}
%
\Prog   & \bnfdef \Assign\some                                   \\
\Assign & \bnfdef \Ident \; âŸ¨{:} \; \Exprâ‚€âŸ©\optional = \Exprâ‚€    \\
\Exprâ‚€  & \bnfdef \Let âˆ£ \If âˆ£ \Lam âˆ£ \CLam âˆ£ \Exprâ‚             \\
\Let    & \bnfdef \exlet{\Assign\many}{\Exprâ‚€}                   \\
\If     & \bnfdef \exif{\Exprâ‚€}{\Exprâ‚€}{\Exprâ‚€}                  \\
\Lam    & \bnfdef \exlam{\Var\some}{\Exprâ‚€}                      \\
\CLam   & \bnfdef \exclam{\Var\some}{\Exprâ‚€}                     \\
\Exprâ‚  & \bnfdef \App âˆ£ \Exprâ‚‚                                  \\
\App    & \bnfdef \exapp{\Exprâ‚}{\Exprâ‚‚}                         \\
\Exprâ‚‚  & \bnfdef \List âˆ£ \Str âˆ£ \TNat âˆ£ \FNat âˆ£ \Pair âˆ£ \Left âˆ£
                  \Right âˆ£ \Trace âˆ£ \Var âˆ£ (\Exprâ‚€)              \\
\List   & \bnfdef [] âˆ£ [\Exprâ‚€ âŸ¨, \Exprâ‚€âŸ©\many]                  \\
\TNat   & \bnfdef \Nat                                           \\
\FNat   & \bnfdef \$\Nat                                         \\
\Pair   & \bnfdef \{\Exprâ‚€, \Exprâ‚€\}                             \\
\Left   & \bnfdef \exleft{\Exprâ‚‚}                                \\
\Right  & \bnfdef \exright{\Exprâ‚‚}                               \\
\Trace  & \bnfdef \extrace{\Exprâ‚‚}                               \\
\Var    & \bnfdef \Ident                                         \\
%
\end{aligned}
%
\end{mathfigure}
%NOTE: The vertical bars in the grammar source are not the ASCII
%      character U+007C VERTICAL LINE but the character U+2223 DIVIDES,
%      which the ucs package translates into \mid. This is important to
%      get the proper spacing.

\subsection{Desugaring}

For defining desugaring, we introduce the following notations:
\begin{itemize}

\item

$âŸ¨eâŸ©_{x â†¦ eâ€²}$ means the expression~$e$ with free occurrences of~$x$
replaced by~$eâ€²$.

\item

$c_{\#}$ means the natural number literal that represents the code of
the character~$c$.

\item

$n_{+}$ means the natural number literal that represents the successor
of~$n$.

\item

$f^{n} x$ means the n-fold application of~$f$ to~$x$, that is,
$\exapp{f}{\exapp{â€¦}{\exapp{f}{\exapp{x}}}}$ where $f$ occurs $n$~times.

\end{itemize}

Desugaring of an expression happens in a context, which is the list of
variables that are in scope, with variables bound closer to the
expression being listed later. We write $Îµ$ for the empty context and $Î”
âŠ³ x$ for the context~$Î”$ extended by~$x$. An internal expression
obtained by desugaring in a context~$Î”$ is supposed to be evaluated in
the environment $\{e_{n}, \{e_{n - 1}, \{â€¦, \{eâ‚, âˆ…\}â€¦\}\}\}$ where
each~$e_{i}$ is the value of the $i$-th variable in~$Î”$.

We introduce a helper function~$Ï : \Var\some Ã— \Var â†’ \Expr\internal$
such that $Ï(Î”, x)$ yields an internal expression that is evaluated to a
pair whose first element is the value of~$x$. The definition of~$Ï$ is
as follows:
\begin{equation}
%
Ï(Î” âŠ³ x, y) = \begin{cases}
                  \kwenv            & \text{if $x = y$} \\
                  \exright{Ï(Î”, y)} & \text{if $x â‰  y$}
              \end{cases}
%
\end{equation}

Figure~\ref{desugaring-of-expressions} defines a function $âŒŠâˆ’âŒ‹_{âˆ’} :
\Expr Ã— \Var\many â†’ \Expr\internal$ that describes desugaring of
expressions. A term $âŒŠeâŒ‹_{Î”}$ gives the internal expression that
corresponds to the surface expression~$e$ in the context~$Î”$. Based on
$âŒŠâˆ’âŒ‹_{âˆ’}$ we define a function $âŒŠâˆ’âŒ‹ : \Prog â†’ \Prog\internal$ that
describes desugaring of programs:
\begin{equation}
%
âŒŠpâŒ‹ = âŒŠ\exlet{p}{\mathit{main}}âŒ‹_{Îµ}
%
\end{equation}
\begin{mathfigure}{desugaring-of-expressions}{Desugaring of expressions}
%
\newcommand{\nextline}{\\ & \mathrel{\phantom{=}}}
\newcommand{\exapprhs}{
    \kwwithenv
    \nextline
    \quad \kwwithenv \; \{
    \nextline
    \quad\quad \exdefer{
                   \{
                       \exleft{\exright{\kwenv}},
                       \{\exleft{\kwenv}, \exright{\exright{\kwenv}}\}
                   \}
               },
    \nextline
    \quad\quad \{âŒŠeâ‚‚âŒ‹_{Î”}, âŒŠeâ‚âŒ‹_{Î”}\}
    \nextline
    \quad \}
}
%
\begin{aligned}
%
âŒŠ\kwlet \; \kwin \; eâŒ‹_{Î”}
    & = âŒŠeâŒ‹_{Î”}                                                   \\
âŒŠ\exlet{x = eâ€² : eâ€³ \; \bar{a}}{e}âŒ‹_{Î”}
     & = âŒŠ\exlet{x = eâ€² \; \bar{a}}{e}âŒ‹_{Î”}                       \\
âŒŠ\exlet{x = eâ€² \; \bar{a}}{e}âŒ‹_{Î”}
     & = âŒŠâŸ¨\exlet{\bar{a}}{e}âŸ©_{x â†¦ eâ€²}âŒ‹_{Î”}                      \\
âŒŠ\exif{e}{eâ‚}{eâ‚‚}âŒ‹_{Î”}
     & = \exwithenv{\{\exgate{âŒŠeâŒ‹_{Î”}}, \{âŒŠeâ‚âŒ‹_{Î”}, âŒŠeâ‚‚âŒ‹_{Î”}\}\}} \\
âŒŠ\exlam{\bar{x}}{e}âŒ‹_{Î”}
     & = \{\exdefer{âŒŠeâŒ‹_{Î” âˆ˜ \bar{x}}}, \kwenv\}                  \\
âŒŠ\exclam{\bar{x}}{e}âŒ‹_{Î”}
     & = \{\exdefer{âŒŠeâŒ‹_{\bar{x}}}, âˆ…\}                           \\
âŒŠ\exapp{eâ‚}{eâ‚‚}âŒ‹_{Î”}
     & = \exapprhs                                                \\
âŒŠ[]âŒ‹_{Î”}
     & = âˆ…                                                        \\
âŒŠ[e, l]âŒ‹_{Î”}
     & = \{âŒŠeâŒ‹_{Î”}, âŒŠ[l]âŒ‹_{Î”}\}                                   \\
âŒŠ\text{â€œ}\,\text{â€}âŒ‹_{Î”}
     & = âˆ…                                                        \\
âŒŠ\text{â€œ}c\bar{c}\text{â€}âŒ‹_{Î”}
     & = \{âŒŠc_{\#}âŒ‹_{Î”}, âŒŠ\text{â€œ}\bar{c}\text{â€}âŒ‹_{Î”}\}          \\
âŒŠ0âŒ‹_{Î”}
     & = âˆ…                                                        \\
âŒŠn_{+}âŒ‹_{Î”}
     & = \{âŒŠnâŒ‹_{Î”}, âˆ…\}                                           \\
âŒŠ\$nâŒ‹_{Î”}
     & = âŒŠ\exclam{f \; x}{f^{n} x}âŒ‹_{Î”}                           \\
âŒŠ\{eâ‚, eâ‚‚\}âŒ‹_{Î”}
     & = \{âŒŠeâ‚âŒ‹_{Î”}, âŒŠeâ‚‚âŒ‹_{Î”}\}                                   \\
âŒŠ\exleft{e}âŒ‹_{Î”}
     & = \exleft{âŒŠeâŒ‹_{Î”}}                                         \\
âŒŠ\exright{e}âŒ‹_{Î”}
     & = \exright{âŒŠeâŒ‹_{Î”}}                                        \\
âŒŠ\extrace{e}âŒ‹_{Î”}
     & = \extrace{âŒŠeâŒ‹_{Î”}}                                        \\
âŒŠxâŒ‹_{Î”}
     & = \exleft{Ï(Î”, x)}                                         \\
âŒŠ(e)âŒ‹_{Î”}
     & = âŒŠeâŒ‹_{Î”}
%
\end{aligned}
%
\end{mathfigure}

\appendix

\section{Potential Problems}
\label{potential-problems}

There are some potential problems with the described version of SIL. We
discuss these problems and suggest a solution for one of them.

\subsection{Evaluation of Function Expressions}

As discussed in Subsection~\ref{internal-language-semantics}, a function
expression~$e$ is evaluated to an expression~$eâ€²$ such that
$\exdefer{eâ€²}$ denotes the same function as~$e$. This design decision
has some unfortunate consequences:
\begin{itemize}

\item

The meaning of an expression may differ depending on whether it is
considered unevaluated or evaluated, and in the evaluated case the
meaning is typically not unique. For example, when seen as unevaluated,
$\{âˆ…, âˆ…\}$ denotes the pair of empty tuples. However, $\{âˆ…, âˆ…\}$ is the
result of evaluating any of the expressions~$e_{i}$ defined as follows:
\begin{align}
eâ‚ & = \{âˆ…, âˆ…\}                     \\
eâ‚‚ & = \{\exdefer{âˆ…}, âˆ…\}           \\
eâ‚ƒ & = \{âˆ…, \exdefer{âˆ…}\}           \\
eâ‚„ & = \{\exdefer{âˆ…}, \exdefer{âˆ…}\} \\
eâ‚… & = \exdefer{\{âˆ…, âˆ…\}}
\end{align}
Therefore, when seen as evaluated, $\{âˆ…, âˆ…\}$ can have any of the
meanings that the~$e_{i}$ have as unevaluated expressions.

\item

As a consequence of the previous point, we need separate typing
relations for evaluated and unevaluated expressions.

\end{itemize}

To make the specification simpler and bring it into line with common
practice, we suggest to change the operational semantics such that the
evaluation results of function expressions are expressions $\exdefer{e}$
instead of just their bodies~$e$. This can be achieved by replacing the
evaluation rules for $\kwwithenv$, $\kwgate$, and $\kwdefer$ with the
ones shown in
Figure~\ref{improved-evaluation-rules-concerning-function-expressions}.
This modification should not change the time and space complexity of
evaluation. With the updated semantics we do not need a separate typing
relation for evaluated expressions anymore: an evaluated expression~$e$
has a type~$Ï„$ if and only if $ğ’¯ âŠ¢ e : Ï„$ is true for any type~$ğ’¯$, in
which case it is true for \emph{every} type~$ğ’¯$.
\begin{mathfigure}
      {improved-evaluation-rules-concerning-function-expressions}
      {Improved evaluation rules concerning function expressions}
%
\begin{gathered}
%
\deriv{â„° âŠ¢ e â†’ \{\exdefer{eâ‚}, eâ‚‚\} \nexthyp eâ‚‚ âŠ¢ eâ‚ â†’ eâ€²}
      {â„° âŠ¢ \exwithenv{e} â†’ eâ€²}
\derivlinedone
\deriv{â„° âŠ¢ e â†’ âˆ…}
      {â„° âŠ¢ \exgate{e} â†’ \exdefer{\exleft{\kwenv}}}
\morederivs
\deriv{â„° âŠ¢ e â†’ eâ€² \nexthyp eâ€² â‰  âˆ…}
      {â„° âŠ¢ \exgate{e} â†’ \exdefer{\exright{\kwenv}}}
\derivlinedone
\deriv{}
      {â„° âŠ¢ \exdefer{e} â†’ \exdefer{e}}
%
\end{gathered}
%
\end{mathfigure}

\subsection{Expressivity}

It looks like SIL programs cannot use any recursion scheme that goes
beyond primitive recursion. The SIL prelude is supposed to provide
several functions that actually need more powerful recursion schemes.
They are approximated using primitive recursion, effectively by starting
with a generally recursive implementation and then placing an upper
bound on the recursion depth. This makes code that uses these functions
difficult to write and reason about.

\subsection{Efficiency}

The two representations of natural numbers (nested pairs and church
encodings) and the representation of environments (nested pairs) are
space and time inefficient without optimization. Since these
representations are on a considerably lower level than the things they
represent, it is probably difficult to rectify their inefficiencies
using domain-specific optimizations.

\subsection{Precision of Types}

In the internal language all nested pairs have the same type. As a
result, all tuple representations of natural numbers have the same type,
which seems sensible. However, in other situations valuable type
information may get lost.

\end{document}

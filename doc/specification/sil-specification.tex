\documentclass{scrartcl}

\deffootnote{1em}{1em}{\textsuperscript{\thefootnotemark}}

\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}

\usepackage
    [bitstream-charter,greekuppercase=italicized]
    {mathdesign}
\renewcommand{\sfdefault}{fvs}
\renewcommand{\ttdefault}{fvm}

\usepackage[utf8x]{inputenc}

\SetUnicodeOption{mathletters}

\PreloadUnicodePage{3}

\DeclareMathSymbol{.}{\mathrel}{letters}{"3A}

\usepackage{microtype}

\usepackage[hidelinks]{hyperref}

\usepackage{amsmath}

\newenvironment{mathfigure}[2]
    {%
        \begin{figure}
        \newcommand{\figurelabel}{#1}
        \newcommand{\figurecaption}{#2}
        \centering
        \begin{math}
    }
    {
        \end{math}
        \caption{\figurecaption}
        \label{\figurelabel}
        \end{figure}%
    }

\newcommand{\bnfdef}{\mathrel{{\mathop:}{\mathop:}{=}}}

\newcommand{\optional}{^{?}}
\newcommand{\some}{^{+}}
\newcommand{\many}{^{*}}

\newcommand{\deriv}[2]{\frac{\;#1\;}{\;#2\;}}
\newcommand{\derivlinedone}{\\[\topsep]}
\newcommand{\morederivs}{\qquad}
\newcommand{\nexthyp}{\quad}

\newcommand{\newkw}[1]
           {\expandafter\newcommand\csname kw#1\endcsname{\mathbf{#1}}}

\newkw{let}
\newkw{in}
\newkw{if}
\newkw{then}
\newkw{else}
\newkw{left}
\newkw{right}
\newkw{trace}

\newkw{env}
\newkw{withenv}
\newkw{gate}
\newkw{defer}
\newkw{abort}

\newcommand{\exlet}[2]{\kwlet \; #1 \; \kwin \; #2}
\newcommand{\exif}[3]{\kwif \; #1 \; \kwthen \; #2 \; \kwelse \; #3}
\newcommand{\exlam}[2]{\backslash \; #1 → #2}
\newcommand{\exclam}[2]{\# \; #1 → #2}
\newcommand{\exapp}[2]{#1 \; #2}
\newcommand{\exleft}[1]{\kwleft \; #1}
\newcommand{\exright}[1]{\kwright \; #1}
\newcommand{\extrace}[1]{\kwtrace \; #1}

\newcommand{\exwithenv}[1]{\kwwithenv \; #1}
\newcommand{\exgate}[1]{\kwgate \; #1}
\newcommand{\exdefer}[1]{\kwdefer \; #1}
\newcommand{\exabort}[1]{\kwabort \; #1}

\newcommand{\newnt}[1]
           {\expandafter\newcommand\csname#1\endcsname{\mathit{#1}}}

\newnt{Char}
\newnt{Letter}
\newnt{Digit}

\newnt{Token}
\newnt{Ident}
\newnt{Str}
\newnt{Nat}
\newnt{Keyword}
\newnt{Symbol}

\newnt{Prog}
\newnt{Assign}
\newnt{Expr}
\newnt{Let}
\newnt{If}
\newnt{Lam}
\newnt{CLam}
\newnt{App}
\newnt{List}
\newnt{TNat}
\newnt{FNat}
\newnt{Pair}
\newnt{Left}
\newnt{Right}
\newnt{Trace}
\newnt{Var}

\newnt{Zero}
\newnt{Env}
\newnt{WithEnv}
\newnt{Gate}
\newnt{Defer}
\newnt{Abort}

\newcommand{\internal}{_{\mathrm{i}}}

\newnt{Type}
\newnt{TypeVar}
\newnt{ZeroType}
\newnt{PairType}
\newnt{FunType}

\title{Specification of the Stand-in Language}
\author{%
    Wolfgang Jeltsch\\
    \small Well-Typed LLP\\
    \small\texttt{wolfgang@well-typed.com}%
}

\begin{document}

\maketitle

\section{Introduction}

We present a formal specification of the Stand-in Language (SIL) by Sam
Griffin. Our specification closely resembles the version of the language
implemented in Commit \texttt{966227a} of the GitHub repository
\texttt{sfultong/stand-in-language}.

SIL actually consists of two languages: the surface language and the
internal language. While the former constitutes the user-facing part,
the latter is the one for which an operational semantics and a type
system are defined.

\section{Notation}

Throughout this document, we describe syntax using a variant of
Backus–Naur form. Our variant uses the following notations, listed here
in increasing order of precedence:
\begin{itemize}

\item

$∣$ denotes set union.

\item

$∖$ denotes set difference.

\item

Mere juxtaposition denotes concatenation.

\item

$\optional$, $\some$, and $\many$ denote optionality, repetition with at
least one occurrence, and arbitrary repetition, respectively.

\item

$⟨$~and~$⟩$ delimit subexpressions and are used for overriding default
precedence.\footnote{We do not use $($ and~$)$ for this purpose, since
they are part of some of the languages we want to describe.}

\item

Words in italics are nonterminals.

\end{itemize}

We introduce further custom notations for various things unrelated to
syntax. Since such notations are tied to specific parts of the
specification, we define them where they are needed.

\section{The Internal Language}

The internal language is a low-level language, which in particular has
no built-in support for closures. It comes with an operational semantics
and a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-internal-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-internal-language}
defines the syntax of the language.
\begin{mathfigure}{token-syntax-of-the-internal-language}
                  {Token syntax of the internal language}
%
\begin{aligned}
%
\Token\internal   & \bnfdef \Keyword\internal ∣ \Symbol\internal     \\
\Keyword\internal & \bnfdef \kwleft ∣ \kwright ∣ \kwwithenv ∣ \kwenv
                            ∣ \kwgate ∣ \kwdefer ∣ \kwabort ∣
                            \kwtrace                                 \\
\Symbol\internal  & \bnfdef {\{} ∣ {,} ∣ {\}} ∣ ∅ ∣ {(} ∣ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-internal-language}
                  {Syntax of the internal language}
%
\begin{aligned}
%
\Prog\internal    & \bnfdef \Expr\internal                      \\
\Expr\internal    & \bnfdef \Pair\internal ∣ \Left\internal ∣
                            \Right\internal ∣ \Zero\internal ∣
                            \WithEnv\internal ∣ \Env\internal ∣
                            \Gate\internal ∣ \Defer\internal ∣
                            \Abort\internal ∣ \Trace\internal ∣
                            (\Expr\internal)                    \\
\Pair\internal    & \bnfdef \{\Expr\internal, \Expr\internal\}  \\
\Left\internal    & \bnfdef \exleft{\Expr\internal}             \\
\Right\internal   & \bnfdef \exright{\Expr\internal}            \\
\Zero\internal    & \bnfdef ∅                                   \\
\WithEnv\internal & \bnfdef \exwithenv{\Expr\internal}          \\
\Env\internal     & \bnfdef \kwenv                              \\
\Gate\internal    & \bnfdef \exgate{\Expr\internal}             \\
\Defer\internal   & \bnfdef \exdefer{\Expr\internal}            \\
\Abort\internal   & \bnfdef \exabort{\Expr\internal}            \\
\Trace\internal   & \bnfdef \extrace{\Expr\internal}
%
\end{aligned}
%
\end{mathfigure}

\subsection{Operational Semantics}

Evaluation of an expression happens in the context of an environment,
which is an expression itself. The environment can be set using
$\kwwithenv$ and read using $\kwenv$.

Figure~\ref{operational-semantics} defines a relation ${−} ⊢ {−} → {−} ⊆
\Expr × \Expr × \Expr$ that constitutes the big-step (evaluation)
semantics of the internal language. A proposition $ℰ ⊢ e → e′$ is true
if and only if evaluating the expression~$e$ in the environment~$ℰ$ may
yield the expression~$e′$.
\begin{mathfigure}{operational-semantics}{Operational semantics}
%
\begin{gathered}
%
\deriv{ℰ ⊢ e₁ → e₁′ \nexthyp ℰ ⊢ e₂ → e₂′}
      {ℰ ⊢ \{e₁, e₂\} → \{e₁′, e₂′\}}
\derivlinedone
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{e₁, e₂\}}
      {ℰ ⊢ \exleft{e} → e₁}
\derivlinedone
\deriv{ℰ ⊢ e → e′ \nexthyp ∀e₁ \; e₂ . e′≠ \{e₁, e₂\}}
      {ℰ ⊢ \exleft{e} → ∅}
%
\end{gathered}
\morederivs
\begin{gathered}
%
\deriv{ℰ ⊢ e → \{e₁, e₂\}}
      {ℰ ⊢ \exright{e} → e₂}
\derivlinedone
\deriv{ℰ ⊢ e → e′ \nexthyp ∀e₁ \; e₂ . e′≠ \{e₁, e₂\}}
      {ℰ ⊢ \exright{e} → ∅}
%
\end{gathered}
\derivlinedone
\deriv{}
      {ℰ ⊢ ∅ → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → \{e₁, e₂\} \nexthyp e₂ ⊢ e₁ → e′}
      {ℰ ⊢ \exwithenv{e} → e′}
\derivlinedone
\deriv{}
      {ℰ ⊢ \kwenv → ℰ}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exgate{e} → \exleft{\kwenv}}
\morederivs
\deriv{ℰ ⊢ e → e′ \nexthyp e′ ≠ ∅}
      {ℰ ⊢ \exgate{e} → \exright{\kwenv}}
\derivlinedone
\deriv{}
      {ℰ ⊢ \exdefer{e} → e}
\derivlinedone
\deriv{ℰ ⊢ e → ∅}
      {ℰ ⊢ \exabort{e} → ∅}
\derivlinedone
\deriv{ℰ ⊢ e → e′}
      {ℰ ⊢ \extrace{e} → e′}
\derivlinedone
%
\end{gathered}
%
\end{mathfigure}

The relation ${−} ⊢ {−} → {−}$ is in fact a partial function. This means
that evaluation is deterministic: it either fails or leads to a uniquely
defined expression.

The semantics only covers the pure aspects of execution. The $\kwtrace$
construct is actually impure, as it outputs diagnostic information. Our
semantics ignores that, treating any expression of the form
$\extrace{e}$ like~$e$.

When $\kwenv$ is encountered during evaluation, it is replaced by the
current environment. Nevertheless, $\kwenv$ may appear in an evaluation
result, namely when the evaluated expression contains $\kwdefer$ or
$\kwgate$. This feature is used to represent functions. The convention
is that an expression $\exdefer{e}$ or $\exgate{e}$ whose evaluation
result is~$e₁$ represents the function that maps any~$e₂$ to the~$e′$
for which $e₂ ⊢ e₁ → e′$. This means that, for example,
$\exdefer{\{\exright{\kwenv}, \exleft{\kwenv}\}}$ represents the
function that swaps the elements of a pair, and $\exgate{∅}$ represents
the first projection function. Under this convention for representing
functions, $\kwwithenv$ is function application and $\kwenv$ is the
current (innermost) argument.

Note that $\kwdefer$ expressions cannot use arguments of surrounding
function expression, as the only way to refer to function arguments is
via $\kwenv$, which always denotes the innermost argument. This means
that the internal language cannot handle closures natively.

\subsection{Type System}

Figure~\ref{type-syntax} defines the syntax of types. Based on that,
Figure~\ref{equivalence-of-types} defines an equivalence relation on
types that identifies all nested pair types. Finally,
Figure~\ref{typing-rules} defines the typing relation ${−} ⊢ {−} : {−} ⊆
\Type × \Expr × \Type$. A proposition $𝒯 ⊢ e : τ$ is true if and only if
the expression~$e$ has type~$τ$ provided that the environment has
type~$𝒯$. Note that the last typing rule establishes that each nested
pair type contains all nested pairs, even those that have a different
structure than the type.
\begin{mathfigure}{type-syntax}{Type syntax}
%
\begin{aligned}
%
\Type     & \bnfdef \Type₀                                        \\
\Type₀    & \bnfdef \FunType ∣ \Type₁                             \\
\FunType  & \bnfdef \Type₁ ⇒ \Type₀                               \\
\Type₁    & \bnfdef \PairType ∣ \ZeroType ∣ \TypeVar ∣ (\Type₀)   \\
\PairType & \bnfdef \{\Type₀, \Type₀\}                            \\
\ZeroType & \bnfdef ∅                                             \\
\TypeVar  & \bnfdef \Letter
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{equivalence-of-types}{Equivalence of types}
%
\begin{gathered}
%
\deriv{}{∅ ≈ \{∅, ∅\}}
\derivlinedone
\deriv{τ₁ ≈ τ₁′ \nexthyp τ₂ ≈ τ₂'}{τ₁ ⇒ τ₂ ≈ τ₁′ ⇒ τ₂′}
\morederivs
\deriv{τ₁ ≈ τ₁′ \nexthyp τ₂ ≈ τ₂'}{\{τ₁, τ₂\} ≈ \{τ₁′, τ₂′\}}
\morederivs
\deriv{}{∅ ≈ ∅}
\morederivs
\deriv{α ∈ \TypeVar}{α ≈ α}
\derivlinedone
\deriv{τ₁ ≈ τ₂}{τ₂ ≈ τ₁}
\morederivs
\deriv{τ₁ ≈ τ₂ \nexthyp τ₂ ≈ τ₃}{τ₁ ≈ τ₃}
\derivlinedone
%
\end{gathered}
%
\end{mathfigure}
\begin{mathfigure}{typing-rules}{Typing rules}
%
\begin{gathered}
%
\deriv{𝒯 ⊢ e₁ : τ₁ \nexthyp 𝒯 ⊢ e₂ : τ₂}{𝒯 ⊢ \{e₁, e₂\} : \{τ₁, τ₂\}}
\derivlinedone
\deriv{𝒯 ⊢ e : \{τ₁, τ₂\}}{𝒯 ⊢ \exleft{e} : τ₁}
\morederivs
\deriv{𝒯 ⊢ e : \{τ₁, τ₂\}}{𝒯 ⊢ \exright{e} : τ₂}
\derivlinedone
\deriv{}{𝒯 ⊢ ∅ : ∅}
\derivlinedone
\deriv{𝒯 ⊢ e : \{τ₁ ⇒ τ₂, τ₁\}}{𝒯 ⊢ \exwithenv{e} : τ₂}
\derivlinedone
\deriv{}{𝒯 ⊢ \kwenv : 𝒯}
\derivlinedone
\deriv{𝒯 ⊢ e : ∅}{𝒯 ⊢ \exgate{e} : \{τ, τ\} ⇒ τ}
\derivlinedone
\deriv{τ₁ ⊢ e : τ₂}{𝒯 ⊢ \exdefer{e} : τ₁ ⇒ τ₂}
\derivlinedone
\deriv{𝒯 ⊢ e : ∅}{𝒯 ⊢ \exabort{e} : ∅}
\derivlinedone
\deriv{𝒯 ⊢ e : τ}{𝒯 ⊢ \extrace{e} : τ}
\derivlinedone
\deriv{τ₁ ≈ τ₂ \nexthyp 𝒯 ⊢ e : τ₁}{𝒯 ⊢ e : τ₂}
\derivlinedone
%
\end{gathered}
%
\end{mathfigure}

\section{The Surface Language}

The surface language is a high-level language, which in particular has
support for closures. Programs in the surface language are translated to
the internal language using a process called desugaring. The surface
language does not have an operational semantics of its own; a surface
language expression is evaluated by first desugaring it and then
evaluating the resulting internal expression. Currently, the surface
language does not have a type system.

\subsection{Syntax}

Figure~\ref{token-syntax-of-the-surface-language} defines the syntax of
tokens. Based on that, Figure~\ref{syntax-of-the-surface-language}
defines the syntax of the language. The nonterminals $\CLam$, $\TNat$,
and $\FNat$ stand for “complete lambda”, “tuple natural”, and “function
natural”, respectively.
\begin{mathfigure}{token-syntax-of-the-surface-language}
                  {Token syntax of the surface language}
%
\begin{aligned}
%
\Token   & \bnfdef \Ident ∣ \Str ∣ \Nat ∣ \Keyword ∣ \Symbol       \\
\Ident   & \bnfdef \Letter⟨\Letter ∣ \Digit ∣ \_ ∣ {′}⟩\many ∖
                   \Keyword                                        \\
\Str     & \bnfdef \text{“}\Char\many\text{”}                      \\
\Nat     & \bnfdef \Digit\some                                     \\
\Keyword & \bnfdef \kwlet ∣ \kwin ∣ \kwif ∣ \kwthen ∣ \kwelse ∣
                   \kwleft ∣ \kwright ∣ \kwtrace                   \\
\Symbol  & \bnfdef {:} ∣ {=} ∣ \backslash ∣ {→} ∣ \# ∣ {[} ∣ {]} ∣
                   {,} ∣ \$ ∣ {\{} ∣ {\}} ∣ {(} ∣ {)}
%
\end{aligned}
%
\end{mathfigure}
\begin{mathfigure}{syntax-of-the-surface-language}
                  {Syntax of the surface language}
%
\begin{aligned}
%
\Prog   & \bnfdef \Assign\some                                   \\
\Assign & \bnfdef \Ident \; ⟨{:} \; \Expr₀⟩\optional = \Expr₀    \\
\Expr₀  & \bnfdef \Let ∣ \If ∣ \Lam ∣ \CLam ∣ \Expr₁             \\
\Let    & \bnfdef \exlet{\Assign\many}{\Expr₀}                   \\
\If     & \bnfdef \exif{\Expr₀}{\Expr₀}{\Expr₀}                  \\
\Lam    & \bnfdef \exlam{\Var\some}{\Expr₀}                      \\
\CLam   & \bnfdef \exclam{\Var\some}{\Expr₀}                     \\
\Expr₁  & \bnfdef \App ∣ \Expr₂                                  \\
\App    & \bnfdef \exapp{\Expr₁}{\Expr₂}                         \\
\Expr₂  & \bnfdef \List ∣ \Str ∣ \TNat ∣ \FNat ∣ \Pair ∣ \Left ∣
                  \Right ∣ \Trace ∣ \Var ∣ (\Expr₀)              \\
\List   & \bnfdef [] ∣ [\Expr₀ ⟨, \Expr₀⟩\many]                  \\
\TNat   & \bnfdef \Nat                                           \\
\FNat   & \bnfdef \$\Nat                                         \\
\Pair   & \bnfdef \{\Expr₀, \Expr₀\}                             \\
\Left   & \bnfdef \exleft{\Expr₂}                                \\
\Right  & \bnfdef \exright{\Expr₂}                               \\
\Trace  & \bnfdef \extrace{\Expr₂}                               \\
\Var    & \bnfdef \Ident                                         \\
%
\end{aligned}
%
\end{mathfigure}
%NOTE: The vertical bars in the grammar source are not the ASCII
%      character U+007C VERTICAL LINE but the character U+2223 DIVIDES,
%      which the ucs package translates into \mid. This is important to
%      get the proper spacing.

\subsection{Desugaring}

For defining desugaring, we introduce the following notations:
\begin{itemize}

\item

$⟨e⟩_{x ↦ e′}$ means the expression~$e$ with free occurrences of~$x$
replaced by~$e′$.

\item

$c_{\#}$ means the natural number literal that represents the code of
the character~$c$.

\item

$n_{+}$ means the natural number literal that represents the successor
of~$n$.

\item

$f^{n} x$ means the n-fold application of~$f$ to~$x$, that is,
$\exapp{f}{\exapp{…}{\exapp{f}{\exapp{x}}}}$ where $f$ occurs $n$~times.

\end{itemize}

Desugaring of an expression happens in a context, which is the list of
variables that are in scope, with variables bound closer to the
expression being listed later. We write $ε$ for the empty context and $Δ
⊳ x$ for the context~$Δ$ extended by~$x$. An internal expression
obtained by desugaring in a context~$Δ$ is supposed to be evaluated in
the environment $\{e_{n}, \{e_{n - 1}, \{…, \{e₁, ∅\}…\}\}\}$ where
each~$e_{i}$ is the value of the $i$-th variable in~$Δ$.

We introduce a helper function~$ρ : \Var\some × \Var → \Expr\internal$
such that $ρ(Δ, x)$ yields an internal expression that is evaluated to a
pair whose first element is the value of~$x$. The definition of~$ρ$ is
as follows:
\begin{equation}
%
ρ(Δ ⊳ x, y) = \begin{cases}
                  \kwenv            & \text{if $x = y$} \\
                  \exright{ρ(Δ, y)} & \text{if $x ≠ y$}
              \end{cases}
%
\end{equation}

Figure~\ref{desugaring-of-expressions} defines a function $⌊−⌋_{−} :
\Expr × \Var\many → \Expr\internal$ that describes desugaring of
expressions. A term $⌊e⌋_{Δ}$ gives the internal expression that
corresponds to the surface expression~$e$ in the context~$Δ$. Based on
$⌊−⌋_{−}$ we define a function $⌊−⌋ : \Prog → \Prog\internal$ that
describes desugaring of programs:
\begin{equation}
%
⌊p⌋ = ⌊\exlet{p}{\mathit{main}}⌋_{ε}
%
\end{equation}
\begin{mathfigure}{desugaring-of-expressions}{Desugaring of expressions}
%
\newcommand{\nextline}{\\ & \mathrel{\phantom{=}}}
\newcommand{\exapprhs}{
    \kwwithenv
    \nextline
    \quad \kwwithenv \; \{
    \nextline
    \quad\quad \exdefer{
                   \{
                       \exleft{\exright{\kwenv}},
                       \{\exleft{\kwenv}, \exright{\exright{\kwenv}}\}
                   \}
               },
    \nextline
    \quad\quad \{⌊e₂⌋_{Δ}, ⌊e₁⌋_{Δ}\}
    \nextline
    \quad \}
}
%
\begin{aligned}
%
⌊\kwlet \; \kwin \; e⌋_{Δ}
    & = ⌊e⌋_{Δ}                                                   \\
⌊\exlet{x = e′ : e″ \; \bar{a}}{e}⌋_{Δ}
     & = ⌊\exlet{x = e′ \; \bar{a}}{e}⌋_{Δ}                       \\
⌊\exlet{x = e′ \; \bar{a}}{e}⌋_{Δ}
     & = ⌊⟨\exlet{\bar{a}}{e}⟩_{x ↦ e′}⌋_{Δ}                      \\
⌊\exif{e}{e₁}{e₂}⌋_{Δ}
     & = \exwithenv{\{\exgate{⌊e⌋_{Δ}}, \{⌊e₁⌋_{Δ}, ⌊e₂⌋_{Δ}\}\}} \\
⌊\exlam{\bar{x}}{e}⌋_{Δ}
     & = \{\exdefer{⌊e⌋_{Δ ∘ \bar{x}}}, \kwenv\}                  \\
⌊\exclam{\bar{x}}{e}⌋_{Δ}
     & = \{\exdefer{⌊e⌋_{\bar{x}}}, ∅\}                           \\
⌊\exapp{e₁}{e₂}⌋_{Δ}
     & = \exapprhs                                                \\
⌊[]⌋_{Δ}
     & = ∅                                                        \\
⌊[e, l]⌋_{Δ}
     & = \{⌊e⌋_{Δ}, ⌊[l]⌋_{Δ}\}                                   \\
⌊\text{“}\,\text{”}⌋_{Δ}
     & = ∅                                                        \\
⌊\text{“}c\bar{c}\text{”}⌋_{Δ}
     & = \{⌊c_{\#}⌋_{Δ}, ⌊\text{“}\bar{c}\text{”}⌋_{Δ}\}          \\
⌊0⌋_{Δ}
     & = ∅                                                        \\
⌊n_{+}⌋_{Δ}
     & = \{⌊n⌋_{Δ}, ∅\}                                           \\
⌊\${n}⌋_{Δ}
     & = ⌊\exclam{f \; x}{f^{n} x}⌋_{Δ}                           \\
⌊\{e₁, e₂\}⌋_{Δ}
     & = \{⌊e₁⌋_{Δ}, ⌊e₂⌋_{Δ}\}                                   \\
⌊\exleft{e}⌋_{Δ}
     & = \exleft{⌊e⌋_{Δ}}                                         \\
⌊\exright{e}⌋_{Δ}
     & = \exright{⌊e⌋_{Δ}}                                        \\
⌊\extrace{e}⌋_{Δ}
     & = \extrace{⌊e⌋_{Δ}}                                        \\
⌊x⌋_{Δ}
     & = \exleft{ρ(Δ, x)}                                         \\
⌊(e)⌋_{Δ}
     & = ⌊e⌋_{Δ}
%
\end{aligned}
%
\end{mathfigure}

\end{document}
